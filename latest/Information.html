<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Information · MIToS</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIToS</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="Installation.html">Installation</a></li><li><a class="toctext" href="Example.html">Example</a></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="MSA.html">MSA</a></li><li class="current"><a class="toctext" href="Information.html">Information</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Counting-residues-1">Counting residues</a></li><li><a class="toctext" href="#Low-count-corrections-1">Low count corrections</a></li><li><a class="toctext" href="#Correction-for-data-redundancy-in-a-MSA-1">Correction for data redundancy in a MSA</a></li><li><a class="toctext" href="#Estimating-information-measures-on-an-MSA-1">Estimating information measures on an MSA</a></li><li><a class="toctext" href="#Corrected-Mutual-Information-1">Corrected Mutual Information</a></li><li><a class="toctext" href="#Visualize-Mutual-Information-1">Visualize Mutual Information</a></li></ul></li><li><a class="toctext" href="SIFTS.html">SIFTS</a></li><li><a class="toctext" href="PDB.html">PDB</a></li><li><a class="toctext" href="Pfam.html">Pfam</a></li></ul></li><li><a class="toctext" href="Scripts.html">Scripts</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="MSA_API.html">MSA</a></li><li><a class="toctext" href="Information_API.html">Information</a></li><li><a class="toctext" href="SIFTS_API.html">SIFTS</a></li><li><a class="toctext" href="PDB_API.html">PDB</a></li><li><a class="toctext" href="Pfam_API.html">Pfam</a></li><li><a class="toctext" href="Utils_API.html">Utils</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modules</li><li><a href="Information.html">Information</a></li></ul><a class="edit-page" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/Information.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Information</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Module-Information-1" href="#Module-Information-1">Information</a></h1><p>The <code>Information</code> module of MIToS defines types and functions useful to calculate information measures (e.g. <em>Mutual Information</em> (MI) and <em>Entropy</em>) over a Multiple Sequence Alignment (MSA). This module was designed to count <code>Residue</code>s (defined in the <code>MSA</code> module) in special contingency tables (as fast as possible) and to derive probabilities from these counts. Also, includes methods for applying corrections to those tables, e.g. pseudocounts and pseudo frequencies. Finally, <code>Information</code> allows to use these probabilities and counts to estimate information measures and other frequency based values.  </p><pre><code class="language-julia">using MIToS.Information # to load the Information module</code></pre><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><ul><li><p>Estimate multi dimensional frequencies and probability tables from sequences, MSAs, etc...</p></li><li><p>Correction for small number of observations</p></li><li><p>Correction for data redundancy on a MSA</p></li><li><p>Estimate information measures</p></li><li><p>Calculate corrected mutual information between residues  </p></li></ul><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="Information.html#Module-Information-1">Information</a></li><ul><li><a href="Information.html#Features-1">Features</a></li><li><a href="Information.html#Contents-1">Contents</a></li><li><a href="Information.html#Counting-residues-1">Counting residues</a></li><ul><ul><li><a href="Information.html#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1">Example: Plotting the probabilities of each residue in a sequence</a></li></ul></ul><li><a href="Information.html#Low-count-corrections-1">Low count corrections</a></li><li><a href="Information.html#Correction-for-data-redundancy-in-a-MSA-1">Correction for data redundancy in a MSA</a></li><li><a href="Information.html#Estimating-information-measures-on-an-MSA-1">Estimating information measures on an MSA</a></li><ul><ul><li><a href="Information.html#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></li></ul></ul><li><a href="Information.html#Corrected-Mutual-Information-1">Corrected Mutual Information</a></li><ul><ul><li><a href="Information.html#Example:-Estimating-corrected-MI-from-an-MSA-1">Example: Estimating corrected MI from an MSA</a></li></ul></ul><li><a href="Information.html#Visualize-Mutual-Information-1">Visualize Mutual Information</a></li></ul></ul><h2><a class="nav-anchor" id="Counting-residues-1" href="#Counting-residues-1">Counting residues</a></h2><p>MIToS Information module defines a multidimensional <code>ContingencyTable</code> type and two types wrapping it, <code>Counts</code> and <code>Probabilities</code>, to store occurrences or probabilities. The <code>ContingencyTable</code> type stores the contingency matrix, its marginal values and total. These types are parametric, taking three ordered parameters:</p><ul><li><p><code>T</code> : The type used for storing the counts or probabilities, e.g. <code>Float64</code>. It&#39;s</p></li></ul><p>possible to use <code>BigFloat</code> if more precision it&#39;s needed.</p><ul><li><p><code>N</code> : It&#39;s the dimension of the table and should be an <code>Int</code>.</p></li><li><p><code>A</code> : This should be a type, subtype of <code>ResidueAlphabet</code>, i.e.: <code>UngappedAlphabet</code>,</p></li></ul><p><code>GappedAlphabet</code> or <code>ReducedAlphabet</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>ContingencyTable</code> can be used for storing probabilities or counts. The wrapper types <code>Probabilities</code> and <code>Counts</code> are mainly intended to dispatch in methods that need to know if the matrix has probabilities or counts, e.g. <code>entropy</code>. In general, the use of <code>ContingencyTable</code> is recommended over the use of <code>Probabilities</code> and <code>Counts</code>.</p></div></div><p>In this way, a matrix for storing pairwise probabilities of residues (without gaps) can be initialized using:  </p><div><pre><code class="language-julia">using MIToS.Information

Pij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} :

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   0.0    0.0
R             │   0.0    0.0
N             │   0.0    0.0
D             │   0.0    0.0
C             │   0.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   0.0    0.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    0.0

total : 0.0</code></pre></div><p><strong>[High level interface]</strong> It is possible to use the functions <code>count</code> and <code>probabilities</code> to easily calculate the frequencies of sequences or columns of a MSA, where the number of sequences/columns determine the dimension of the resulting table.  </p><div><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA # to use res&quot;...&quot; to create Vector{Residue}

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Nij[R,R] =   1     1   = 2

Nij = count(column_i, column_j)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} :

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 1.0  1.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  2.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 2.0  0.0  0.0  1.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  1.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   2.0    3.0
R             │   2.0    3.0
N             │   1.0    1.0
D             │   3.0    1.0
C             │   1.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   1.0    1.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    1.0

total : 10.0</code></pre></div><p>You can use <code>sum</code> to get the stored total:  </p><div><pre><code class="language-julia">sum(Nij) # There are 12 Residues, but 2 are gaps</code></pre><pre><code class="language-none">10.0</code></pre></div><p>Contingency tables can be indexed using <code>Int</code> or <code>Residue</code>s:  </p><div><pre><code class="language-julia">Nij[2, 2] # Use Int to index the table</code></pre><pre><code class="language-none">2.0</code></pre></div><div><pre><code class="language-julia">Nij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre><code class="language-none">2.0</code></pre></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The number makes reference to the specific index in the table e.g <code>[2,2]</code> references the second row and the second column. The use of the number used to encode the residue to index the table is dangerous. The equivalent index number of a residue depends on the used alphabet and <code>Int(Residue(&#39;X&#39;))</code> will be always out of bounds.  </p></div></div><p>Indexing with <code>Residue</code>s works as expected. It uses the alphabet of the contingency table to find the index of the <code>Residue</code>.</p><div><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Fij[R,R] =   1  1  1   = 3 # RHK

Fij = count(column_i, column_j, alphabet=alphabet)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} :

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    0.0    1.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    3.0    0.0    0.0    0.0    0.0    0.0
DE            │   2.0    0.0    0.0    1.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   2.0    4.0
NQST          │   1.0    1.0
RHK           │   3.0    4.0
DE            │   3.0    1.0
FWY           │   0.0    0.0
C             │   1.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 10.0</code></pre></div><div><pre><code class="language-julia">Fij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre><code class="language-none">3.0</code></pre></div><p>The function <code>getcontingencytable</code> allows to access the wrapped <code>ContingencyTable</code> in a <code>Counts</code> object. You can use it, in combination with <code>normalize</code> to get a contingency table of probabilities. The result can be wrapped inside a <code>Probabilities</code> object:  </p><div><pre><code class="language-julia">Probabilities(normalize(getcontingencytable(Fij)))</code></pre><pre><code class="language-none">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} :

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.1    0.0    0.1    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.1    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.3    0.0    0.0    0.0    0.0    0.0
DE            │   0.2    0.0    0.0    0.1    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.1    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.2    0.4
NQST          │   0.1    0.1
RHK           │   0.3    0.4
DE            │   0.3    0.1
FWY           │   0.0    0.0
C             │   0.1    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 1.0</code></pre></div><h4><a class="nav-anchor" id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1">Example: Plotting the probabilities of each residue in a sequence</a></h4><p>Similar to the <code>count</code> function, the <code>probabilities</code> function can take at least one sequence (vector of residues) and returns the probabilities of each residue. Optionally, the keyword argument <code>alphabet</code> could be used to count some residues in the same cell of the table.  </p><div><pre><code class="language-julia">probabilities(res&quot;AARANHDDRDC&quot;, alphabet=alphabet)</code></pre><pre><code class="language-none">MIToS.Information.Probabilities{Float64,1,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.ReducedAlphabet} :

table : 8-element Named Array{Float64,1}
Dim_1  │
───────┼──────────
AILMV  │  0.272727
NQST   │ 0.0909091
RHK    │  0.272727
DE     │  0.272727
FWY    │       0.0
C      │ 0.0909091
G      │       0.0
P      │       0.0

total : 1.0</code></pre></div><p>Here, we are going to use the <code>probabilities</code> function to get the residue probabilities of a particular sequence from <em>UniProt</em>.</p><p>use the <code>getsequence</code> function, from the <code>MSA</code> module, to get the sequence from a <code>FASTA</code> downloaded from UniProt.  </p><pre><code class="language-julia-repl">julia&gt; using MIToS.Information # to use the probabilities function

julia&gt; using MIToS.MSA # to use getsequence on the one sequence FASTA (canonical) from UniProt

julia&gt; seq = read(&quot;http://www.uniprot.org/uniprot/P29374.fasta&quot;, FASTA) # Small hack: read the single sequence as a MSA
AnnotatedMultipleSequenceAlignment with 0 annotations : 1×1257 Named Array{MIToS.MSA.Residue,2}
                                                                                                 Seq ╲ Col │   …
───────────────────────────────────────────────────────────────────────────────────────────────────────────┼──────
sp|P29374|ARI4A_HUMAN AT-rich interactive domain-containing protein 4A OS=Homo sapiens GN=ARID4A PE=1 SV=3 │   …

julia&gt; probabilities(seq[1,:]) # Select the single sequence and calculate the probabilities
MIToS.Information.Probabilities{Float64,1,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.UngappedAlphabet} :

table : 20-element Named Array{Float64,1}
Dim_1  │
───────┼───────────
A      │   0.043755
R      │  0.0517104
N      │  0.0469372
D      │  0.0755768
C      │  0.0135243
Q      │   0.035004
E      │   0.134447
G      │   0.043755
H      │  0.0143198
⋮                 ⋮
K      │   0.109785
M      │  0.0159109
F      │  0.0190931
P      │  0.0445505
S      │   0.100239
T      │  0.0493238
W      │ 0.00636436
Y      │  0.0198886
V      │  0.0517104

total : 1.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In the previous example, using <code>getsequence(seq,1)</code> instead of <code>seq[1,:]</code> will return the sequence as a matrix with a single column to keep information for both dimensions. To use <code>probabilities</code> (or <code>count</code>) you can make use of the Julia&#39;s <code>vec</code> function to transform the matrix to a vector, e.g.: <code>probabilities(vec(getsequence(seq,1)))</code>.</p></div></div><div></div><div><pre><code class="language-julia">using Plots # We choose Plots because it&#39;s intuitive, concise and backend independent
pyplot(size=(600,300))</code></pre><pre><code class="language-none">Plots.PyPlotBackend()</code></pre></div><p>You can plot together with the probabilities of each residue in a given sequence, the probabilities of each residue estimated with the BLOSUM62 substitution matrix. That matrix is exported as a constant by the <code>Information</code> module as <code>BLOSUM62_Pi</code>.  </p><div><pre><code class="language-julia">bar(
    1:20,
    [ frequencies  BLOSUM62_Pi ],
    lab = [ &quot;Sequence&quot;  &quot;BLOSUM62&quot;   ],
    alpha=0.5
    )</code></pre></div><p><img src="inf_plotfreq.png" alt/>  </p><h2><a class="nav-anchor" id="Low-count-corrections-1" href="#Low-count-corrections-1">Low count corrections</a></h2><p>Low number of observations can lead to sparse contingency tables, that lead to wrong probability estimations. It is shown in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="assets/external-link.png" alt/></a> that low-count corrections, can lead to improvements in the contact prediction capabilities of the Mutual Information. The Information module has available two low-count corrections:  </p><ol><li><p><a href="https://en.wikipedia.org/wiki/Additive_smoothing">Additive Smoothing<img src="assets/external-link.png" alt/></a>; the constant value pseudocount described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="assets/external-link.png" alt/></a>.  </p></li><li><p>BLOSUM62 based pseudo frequencies of residues pairs, similar to <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC146917/"><em>Altschul et. al. 1997</em><img src="assets/external-link.png" alt/></a>.  </p></li></ol><div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)

filtercolumns!(msa, columngapfraction(msa) .&lt; 0.5) # delete columns with 50% gaps or more

column_i = msa[:,1]
column_j = msa[:,2]</code></pre><pre><code class="language-none">178-element Named Array{MIToS.MSA.Residue,1}
Seq                        │
───────────────────────────┼──
E4XN03_OIKDI/34-146        │ -
G1RVK4_NOMLE/46-161        │ R
A0A0V0S2G9_9BILA/731-840   │ S
B4NHY3_DROWI/2-106         │ -
G6CRH5_DANPL/1-73          │ -
A0A194PY65_PAPXU/4-116     │ -
RM55_DROME/2-106           │ -
G5C999_HETGA/5-102         │ -
G7Y6C1_CLOSI/30-139        │ -
⋮                            ⋮
M3WM55_FELCA/10-125        │ H
A0A0C2BEU2_9BILA/5-105     │ -
A0A0N5CCD5_STREA/1-104     │ -
B4QTH5_DROSI/2-106         │ -
T1FXF3_HELRO/1-90          │ -
A0A090MXF3_STRRB/2-104     │ -
G3WPK1_SARHA/11-126        │ H
RM55_MOUSE/9-124           │ H
M3XPJ7_MUSPF/10-125        │ R</code></pre></div><p>If you have a preallocated <code>ContingencyTable</code> you can use <code>count!</code> to fill it, this prevent to create a new table as <code>count</code> do. However, you should note that <code>count!</code> <strong>adds the new counts to the pre existing values</strong>, so in this case, we want to start with a table initialized with zeros.  </p><div><pre><code class="language-julia">using MIToS.Information

const alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

Nij = ContingencyTable(Float64, Val{2}, alphabet)</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} :

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
DE            │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.0    0.0
NQST          │   0.0    0.0
RHK           │   0.0    0.0
DE            │   0.0    0.0
FWY           │   0.0    0.0
C             │   0.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 0.0</code></pre></div><div><pre><code class="language-julia">#      table  weights         pseudocount      sequences...
count!(Nij,   NoClustering(), NoPseudocount(), column_i, column_j)</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} :

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    1.0    9.0    0.0    0.0    0.0    2.0    0.0
NQST          │   2.0   10.0    1.0    0.0    2.0    5.0    1.0    0.0
RHK           │   2.0    2.0   21.0    0.0    3.0   11.0    1.0    0.0
DE            │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    1.0    1.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    4.0    8.0    0.0    1.0    4.0    0.0    0.0
G             │   0.0    2.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  12.0    5.0
NQST          │  21.0   20.0
RHK           │  40.0   40.0
DE            │   0.0    0.0
FWY           │   2.0    6.0
C             │  17.0   20.0
G             │   2.0    4.0
P             │   1.0    0.0

total : 95.0</code></pre></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>You can use <code>NoClustering()</code> in places where clustering weights are required to not use weights. Also, <code>NoPseudocount()</code> in places where pseudocount values are required to not use pseudocounts.</p></div></div><p>In cases like the above, where there are few observations, it is possible to apply a constant pseudocount to the counting table.  This module defines the type <code>AdditiveSmoothing</code> and the correspond <code>fill!</code> and  <code>apply_pseudocount!</code> methods to efficiently add or fill with a constant value each element of the table.</p><div><pre><code class="language-julia">apply_pseudocount!(Nij, AdditiveSmoothing(1.0))</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} :

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    2.0   10.0    1.0    1.0    1.0    3.0    1.0
NQST          │   3.0   11.0    2.0    1.0    3.0    6.0    2.0    1.0
RHK           │   3.0    3.0   22.0    1.0    4.0   12.0    2.0    1.0
DE            │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    2.0    2.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    5.0    9.0    1.0    2.0    5.0    1.0    1.0
G             │   1.0    3.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   2.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  20.0   13.0
NQST          │  29.0   28.0
RHK           │  48.0   48.0
DE            │   8.0    8.0
FWY           │  10.0   14.0
C             │  25.0   28.0
G             │  10.0   12.0
P             │   9.0    8.0

total : 159.0</code></pre></div><p><strong>[High level interface.]</strong> The <code>count</code> function has a <code>pseudocounts</code> keyword argument that can take a <code>AdditiveSmoothing</code> value to easily calculate occurrences with pseudocounts. Also the alphabet keyword argument can be used to chage the default alphabet (i.e. )</p><div><pre><code class="language-julia">count(column_i, column_j, pseudocounts=AdditiveSmoothing(1.0), alphabet=alphabet)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} :

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    2.0   10.0    1.0    1.0    1.0    3.0    1.0
NQST          │   3.0   11.0    2.0    1.0    3.0    6.0    2.0    1.0
RHK           │   3.0    3.0   22.0    1.0    4.0   12.0    2.0    1.0
DE            │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    2.0    2.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    5.0    9.0    1.0    2.0    5.0    1.0    1.0
G             │   1.0    3.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   2.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  20.0   13.0
NQST          │  29.0   28.0
RHK           │  48.0   48.0
DE            │   8.0    8.0
FWY           │  10.0   14.0
C             │  25.0   28.0
G             │  10.0   12.0
P             │   9.0    8.0

total : 159.0</code></pre></div><p>To use the conditional probability matrix <code>BLOSUM62_Pij</code> in the calculation of pseudo frequencies <span>$G$</span> for the pair of residues <span>$a$</span>, <span>$b$</span>, it should be calculated first the real frequencies/probabilities <span>$p_{a,b}$</span>. The observed probabilities are then used to estimate the pseudo frequencies.  </p><div>\[G_{ab} = \sum_{cd}  p_{cd} \cdot BLOSUM62( a | c ) \cdot BLOSUM62( b | d )\]</div><p>Finally, the probability <span>$P$</span> of each pair of residues <span>$a$</span>, <span>$b$</span> between the columns <span>$i$</span>, <span>$j$</span> is the weighted mean between the observed frequency <span>$p$</span> and BLOSUM62-based pseudo frequency <span>$G$</span>, where α is generally the number of clusters or the number of sequences of the MSA and β is an empiric weight value. β was determined to be close to <code>8.512</code>.  </p><div>\[P_{ab} = \frac{\alpha \cdot p_{ab} + \beta \cdot G_{ab} }{\alpha + \beta}\]</div><p>This could be easily achieved using the <code>pseudofrequencies</code> keyword argument of the <code>probabilities</code> function. That argument can take a <code>BLOSUM_Pseudofrequencies</code> object that is created with α and β as first and second argument, respectively.</p><div><pre><code class="language-julia">Pij = probabilities(column_i, column_j, pseudofrequencies=BLOSUM_Pseudofrequencies(nsequences(msa), 8.512))</code></pre><pre><code class="language-none">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} :

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │           A            R  …            Y            V
──────────────┼──────────────────────────────────────────────────────
A             │ 0.000200739    0.0102745  …  0.000100287  0.000131278
R             │ 0.000367889    0.0709206       0.0203914  0.000273342
N             │ 0.000137237  0.000119185      6.37001e-5   8.91908e-5
D             │  9.54315e-5   9.55298e-5      5.02528e-5   6.64555e-5
C             │ 0.000266746    0.0204132       0.0102489  0.000166391
Q             │ 0.000120495  0.000133352      6.57726e-5   9.18663e-5
E             │ 0.000124372   0.00014048      7.17899e-5   9.10347e-5
G             │ 0.000166918  0.000140118      6.99607e-5   9.89338e-5
H             │  8.30989e-5   8.48861e-5      6.11241e-5   5.71344e-5
⋮                         ⋮            ⋮  ⋱            ⋮            ⋮
K             │ 0.000191556  0.000254845     0.000129199  0.000146252
M             │  4.97407e-5   6.00345e-5      2.77798e-5   3.33784e-5
F             │  8.10509e-5   7.95621e-5      3.96533e-5   4.79409e-5
P             │  6.90459e-5   7.06432e-5      3.80607e-5   6.30076e-5
S             │ 0.000210055  0.000177697     0.000101738  0.000147911
T             │ 0.000133685  0.000134698      6.86807e-5   9.33539e-5
W             │  1.61993e-5   1.86925e-5       9.7159e-6   1.08245e-5
Y             │  6.08181e-5   6.69783e-5      3.96913e-5   3.97839e-5
V             │ 0.000168302  0.000223887  …   8.09729e-5  0.000106123

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │       Dim_1        Dim_2
──────────────┼─────────────────────────
A             │   0.0332277   0.00284131
R             │    0.358362      0.10378
N             │   0.0321149   0.00172538
D             │  0.00146444   0.00148035
C             │     0.17516     0.205964
Q             │   0.0521598    0.0216689
E             │  0.00200663   0.00195809
G             │   0.0223478    0.0429226
H             │    0.041674     0.215154
⋮                         ⋮            ⋮
K             │   0.0133355     0.093596
M             │ 0.000798111  0.000801491
F             │   0.0112275    0.0216895
P             │   0.0112054  0.000946134
S             │    0.123641     0.164065
T             │    0.012111    0.0221748
W             │  0.00026151    0.0105836
Y             │   0.0110642    0.0318123
V             │   0.0730264   0.00194366

total : 1.0</code></pre></div><p>You can also use <code>apply_pseudofrequencies!</code> in a previously filled probability contingency table. i.e. <code>apply_pseudofrequencies!(Pij, BLOSUM_Pseudofrequencies(α, β))</code></p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>BLOSUM_Pseudofrequencies</code> can be only be applied in <strong>normalized/probability</strong> tables with <code>UngappedAlphabet</code>.  </p></div></div><h2><a class="nav-anchor" id="Correction-for-data-redundancy-in-a-MSA-1" href="#Correction-for-data-redundancy-in-a-MSA-1">Correction for data redundancy in a MSA</a></h2><p>A simple way to reduce redundancy in a MSA without losing sequences, is clusterization and sequence weighting. The weight of each sequence should be 1/N, where N is the number of sequences in its cluster. The <code>Clusters</code> type of the <code>MSA</code> module stores the weights. This vector of weights can be extracted (with the <code>getweight</code> function) and used by the <code>count</code> and <code>probabilities</code> functions with the keyword argument <code>weights</code>. Also it&#39;s possible to use the <code>Clusters</code> as second argument of the function <code>count!</code>.  </p><div><pre><code class="language-julia">clusters = hobohmI(msa, 62) # from MIToS.MSA</code></pre><pre><code class="language-none">MIToS.MSA.Clusters([1, 43, 2, 15, 2, 2, 1, 1, 1, 6  …  2, 3, 1, 1, 1, 2, 1, 1, 1, 1], [1, 2, 3, 4, 5, 4, 4, 2, 6, 7  …  15, 2, 16, 28, 4, 64, 28, 2, 2, 2], [1.0, 0.0232558, 0.5, 0.0666667, 0.5, 0.0666667, 0.0666667, 0.0232558, 0.5, 1.0  …  0.142857, 0.0232558, 0.2, 0.25, 0.0666667, 1.0, 0.25, 0.0232558, 0.0232558, 0.0232558])</code></pre></div><div><pre><code class="language-julia">count(msa[:,1], msa[:,2], weights=clusters)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} :

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │         A          R  …          Y          V
──────────────┼──────────────────────────────────────────────
A             │       0.0  0.0232558  …        0.0        0.0
R             │       0.0    1.61628      0.523256        0.0
N             │       0.0        0.0           0.0        0.0
D             │       0.0        0.0           0.0        0.0
C             │       0.0   0.273256      0.166667        0.0
Q             │       0.0        0.0           0.0        0.0
E             │       0.0        0.0           0.0        0.0
G             │       0.0        0.0           0.0        0.0
H             │       0.0        0.0           0.0        0.0
⋮                       ⋮          ⋮  ⋱          ⋮          ⋮
K             │       0.0        0.0           0.0        0.0
M             │       0.0        0.0           0.0        0.0
F             │       0.0        0.0           0.0        0.0
P             │       0.0        0.0           0.0        0.0
S             │       0.0        0.0           0.0        0.0
T             │       0.0        0.0           0.0        0.0
W             │       0.0        0.0           0.0        0.0
Y             │       0.0        0.0           0.0        0.0
V             │       0.0        0.0  …        0.0        0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │     Dim_1      Dim_2
──────────────┼─────────────────────
A             │   1.22326        0.0
R             │   6.17132    1.91279
N             │       1.5        0.0
D             │       0.0        0.0
C             │   3.21938    3.34574
Q             │       4.0    1.06667
E             │       0.0        0.0
G             │   0.47619    1.42326
H             │   1.06977     1.9186
⋮                       ⋮          ⋮
K             │       0.2        1.5
M             │       0.0        0.0
F             │       1.0        0.4
P             │      0.25        0.0
S             │   4.36611    7.93571
T             │  0.166667        2.0
W             │       0.0  0.0232558
Y             │ 0.0232558   0.689922
V             │     0.875        0.0

total : 25.665946843853824</code></pre></div><h2><a class="nav-anchor" id="Estimating-information-measures-on-an-MSA-1" href="#Estimating-information-measures-on-an-MSA-1">Estimating information measures on an MSA</a></h2><p>The <code>Information</code> module has a number of functions defined to calculate information measures from <code>Counts</code> and <code>Probabilities</code>:</p><ul><li><p><code>entropy</code> : Shannon entropy (H)</p></li><li><p><code>marginal_entropy</code> : Shannon entropy (H) of the marginals</p></li><li><p><code>kullback_leibler</code> : Kullback-Leibler (KL) divergence</p></li><li><p><code>mutual_information</code> : Mutual Information (MI)</p></li><li><p><code>normalized_mutual_information</code> : Normalized Mutual Information (nMI) by Entropy</p></li><li><p><code>gap_intersection_percentage</code></p></li><li><p><code>gap_union_percentage</code></p></li></ul><p>Information measure functions take optionally the base as the last positional argument (default: <code>e</code>). You can use <code>2.0</code> to measure information in bits.</p><div><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

Ni = count(res&quot;PPCDPPPPPKDKKKKDDGPP&quot;) # Ni has the count table of residues in this low complexity sequence

H = entropy(Ni) # returns the Shannon entropy in nats (base e)</code></pre><pre><code class="language-none">1.327362863420189</code></pre></div><div><pre><code class="language-julia">H = entropy(Ni, 2.0) # returns the Shannon entropy in bits (base 2)</code></pre><pre><code class="language-none">1.9149798205164812</code></pre></div><p>Information module defines special iteration functions to easily and efficiently compute a measure over a MSA. In particular, <code>mapcolfreq!</code> and <code>mapseqfreq!</code> map a function that takes a table of <code>Counts</code> or <code>Probabilities</code>. The table is filled in place with the counts or probabilities of each column or sequence of a MSA, respectively. <code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> are similar, but they fill the table using pairs of columns or sequences, respectively.  </p><p>This functions take three positional arguments: the function <code>f</code> to be calculated, the <code>msa</code> and <code>table</code> of <code>Counts</code> or <code>Probabilities</code>.  </p><p>After that, this function takes some keyword arguments:</p><ul><li><p><code>weights</code> (default: <code>NoClustering()</code>) : Weights to be used for table counting.</p></li><li><p><code>pseudocounts</code> (default: <code>NoPseudocount()</code>) : <code>Pseudocount</code> object to be applied to table.</p></li><li><p><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>) : <code>Pseudofrequencies</code> to be</p></li></ul><p>applied to the normalized (probabilities) table.  </p><p><code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> also have a fourth positional argument <code>usediagonal</code> that indicates if the function should be applied to identical element pairs (default to <code>Val{true}</code>). This two functions also have an extra keyword argument <code>diagonalvalue</code> (default to zero) to indicate the value used to fill the diagonal elements if <code>usediagonal</code> is <code>Val{false}</code>.  </p><h4><a class="nav-anchor" id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></h4><p>In this example, we are going to use <code>mapcolfreq!</code> and <code>mapcolpairfreq!</code> to estimate Shannon <code>entropy</code> of MSA columns <em>H(X)</em> and the joint entropy <em>H(X, Y)</em> of columns pairs, respectively.  </p><div></div><div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 202 annotations : 178×116 Named Array{MIToS.MSA.Residue,2}
                 Seq ╲ Col │  26   27   28   29   30  …  165  166  167  168  169
───────────────────────────┼────────────────────────────────────────────────────
E4XN03_OIKDI/34-146        │   -    -    -    -    -  …    -    -    -    -    -
G1RVK4_NOMLE/46-161        │   -    L    R    Q    S       Q    F    W    T    R
A0A0V0S2G9_9BILA/731-840   │   -    -    -    -    -       Y    L    W    K    K
B4NHY3_DROWI/2-106         │   -    -    -    -    -       K    F    I    K    K
G6CRH5_DANPL/1-73          │   -    -    -    -    -       K    Y    L    K    K
A0A194PY65_PAPXU/4-116     │   -    -    -    -    -       K    Y    I    K    K
RM55_DROME/2-106           │   -    -    -    -    -       K    Y    I    K    K
G5C999_HETGA/5-102         │   -    -    -    -    -       R    F    W    T    -
G7Y6C1_CLOSI/30-139        │   -    -    -    -    -       F    L    -    -    -
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
M3WM55_FELCA/10-125        │   L    L    R    Q    H       Q    F    W    T    K
A0A0C2BEU2_9BILA/5-105     │   -    -    -    -    -       K    F    W    S    -
A0A0N5CCD5_STREA/1-104     │   -    -    -    -    -       G    L    W    K    -
B4QTH5_DROSI/2-106         │   -    -    -    -    -       K    Y    I    K    K
T1FXF3_HELRO/1-90          │   -    -    -    -    -       Y    L    W    K    K
A0A090MXF3_STRRB/2-104     │   -    -    -    -    -       K    L    W    K    -
G3WPK1_SARHA/11-126        │   -    L    Q    Q    N       K    F    W    K    K
RM55_MOUSE/9-124           │   L    L    R    H    C       Q    F    W    T    K
M3XPJ7_MUSPF/10-125        │   -    L    Q    Q    P  …    R    F    W    T    K</code></pre></div><p>We are going to count residues to estimate the entropy. The <code>entropy</code> estimation is performed over a rehused <code>Counts</code> object. The result will be a vector containing the values estimated over each column without counting gaps (<code>UngappedAlphabet</code>).  </p><div><pre><code class="language-julia">using MIToS.Information

Hx = mapcolfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{1}, UngappedAlphabet())))</code></pre><pre><code class="language-none">1×116 Named Array{Float64,2}
   Function ╲ Col │        26         27  …        168        169
──────────────────┼──────────────────────────────────────────────
StatsBase.entropy │  0.154076   0.104732  …    1.45319   0.389377</code></pre></div><p>If we want the <strong>joint entropy</strong> between columns pairs, we need to use a bidimensional table of <code>Counts</code> and <code>mapcolpairfreq!</code>.</p><div><pre><code class="language-julia">Hxy = mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))</code></pre><pre><code class="language-none">116×116 Named PairwiseListMatrices.PairwiseListMatrix{Float64,true,Array{Float64,1}}
Col1 ╲ Col2 │       26        27        28  …       167       168       169
────────────┼──────────────────────────────────────────────────────────────
26          │ 0.154076  0.154076   1.31712  …  0.158411   1.21392  0.523586
27          │ 0.154076  0.104732   1.22963     0.110453   1.24079  0.617242
28          │  1.31712   1.22963   1.21303      1.22746   2.18138   1.52297
29          │ 0.657599  0.691757   1.85316     0.789908   1.76837   1.30739
30          │  1.68486   1.88893   2.43484      2.04833    2.6745   2.26013
31          │  1.70705   1.65135    2.3727      1.93191   2.60141   1.88972
32          │  1.18671   1.24484   2.19531      1.58709   2.31757   1.89908
33          │  1.56679   1.46489   2.29681      1.87687    2.5379    2.0889
34          │  1.35059    1.3686   2.20335      1.64673   2.39524   1.76504
⋮                    ⋮         ⋮         ⋮  ⋱         ⋮         ⋮         ⋮
161         │ 0.315396  0.361788   1.53444      2.32731   2.63551   1.90222
162         │  1.23122   1.27751   2.12047      2.59423   2.70685   2.25488
163         │ 0.158411  0.110453   1.22746      1.03774   1.48904  0.438413
164         │  1.18782   1.28922   2.24043      2.82306     2.924   2.37534
165         │  1.00747   1.04469   1.90654      2.50421   2.57873   2.00587
166         │ 0.315396  0.220352   1.29571      1.69791   2.19351   1.39281
167         │ 0.158411  0.110453   1.22746      1.01288   2.12922   1.25158
168         │  1.21392   1.24079   2.18138      2.12922   1.45319   1.64239
169         │ 0.523586  0.617242   1.52297  …   1.25158   1.64239  0.389377</code></pre></div><p>In the above examples, we indicate the type of each occurrence in the counting and the probability table to use. Also, it&#39;s possible for some measures as <strong>entropy</strong> and <strong>mutual information</strong>, to estimate the values only with the count table (without calculate the probability table). Estimating measures only with a <code>ResidueCount</code> table, when this is possible, should be faster than using a probability table.  </p><div><pre><code class="language-julia">Time_Pab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Probabilities(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

Time_Nab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

using Plots
pyplot()

histogram( [Time_Pab Time_Nab],
    labels = [&quot;Using ResidueProbability&quot; &quot;Using ResidueCount&quot;],
    xlabel = &quot;Execution time [seconds]&quot; )</code></pre></div><p><img src="inf_entropy.png" alt/>   </p><h2><a class="nav-anchor" id="Corrected-Mutual-Information-1" href="#Corrected-Mutual-Information-1">Corrected Mutual Information</a></h2><p>MIToS ships with two methods to easily calculate corrected mutual information.   The first is the algorithm described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="assets/external-link.png" alt/></a>. This algorithm can be accessed through the <code>buslje09</code> function and includes:  </p><ol><li><p>Low count correction using <code>AdditiveSmoothing</code></p></li><li><p>Sequence weighting after a <code>hobohmI</code> clustering</p></li><li><p>Average Product Correction (APC) proposed by</p></li></ol><p><a href="http://bioinformatics.oxfordjournals.org/content/24/3/333">Dunn et. al. 2008<img src="assets/external-link.png" alt/></a>, through the <code>APC!</code> function that takes a MI matrix.</p><ol><li><p>Z score correction using the functions <code>shuffle!</code> from the MSA module and <code>zscore</code></p></li></ol><p>from the <code>PairwiseListMatrices</code> package.  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.buslje09" href="#MIToS.Information.buslje09"><code>MIToS.Information.buslje09</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>buslje09</code> takes a MSA or a file and a <code>Format</code> as first arguments. It calculates a Z score and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong>.</p><p>keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - lambda      Float64   0.05    Low count value
  - clustering  Bool      true    Sequence clustering (Hobohm I)
  - threshold             62      Percent identity threshold for clustering
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       100     Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples
  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score
  - MI or MIp</code></pre></div><a class="source-link" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/1ef26a8284a0fb3059e4caebfac8de860ffceb1c/src/Information/CorrectedMutualInformation.jl#L19-L42">source</a></section><p>The second, implemented in the <code>BLMI</code> function, has the same corrections that the above algorithm, but use BLOSUM62 pseudo frequencies. This function is <strong>slower</strong> than <code>buslje09</code> (at the same number of samples), but gives <strong>better performance</strong> (for structural contact prediction) when the MSA has <strong>less than 400 clusters</strong> after a Hobohm I at 62% identity.  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.BLMI" href="#MIToS.Information.BLMI"><code>MIToS.Information.BLMI</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>BLMI</code> takes a MSA or a file and a <code>Format</code> as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong> but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.</p><p>Keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies
  - lambda      Float64   0.0     Low count value
  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       50      Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score (ZBLMI)
  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/1ef26a8284a0fb3059e4caebfac8de860ffceb1c/src/Information/CorrectedMutualInformation.jl#L94-L117">source</a></section><h4><a class="nav-anchor" id="Example:-Estimating-corrected-MI-from-an-MSA-1" href="#Example:-Estimating-corrected-MI-from-an-MSA-1">Example: Estimating corrected MI from an MSA</a></h4><div></div><div><pre><code class="language-julia">using MIToS.MSA
using MIToS.Information

msa = read(&quot;http://pfam.xfam.org/family/PF16078/alignment/full&quot;, Stockholm)
ZMIp, MIp  = buslje09(msa)
ZMIp</code></pre><pre><code class="language-none">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │          15           16  …           57           58
────────────┼──────────────────────────────────────────────────────
15          │         NaN     -0.19098  …     -2.87993     0.953847
16          │    -0.19098          NaN       -0.435745       1.8082
17          │     3.14201      1.51272       0.0955998     0.662577
18          │   -0.174606     0.870042         1.22376    -0.236976
19          │    -1.63054     -1.63054         4.32741     -1.09972
20          │    -3.79544     0.681661         1.22899     -2.03112
21          │     1.99496    -0.927665         2.32921     -1.12028
25          │     -3.3053     -2.17551        0.141383     -3.62681
26          │     -4.2503     -2.96422        -1.74523     -2.93503
⋮                       ⋮            ⋮  ⋱            ⋮            ⋮
50          │    -1.35473    -0.871037         2.94287     -1.05186
51          │    -1.97049      5.80037         9.10315      -0.5465
52          │      4.6033      -2.2011        -2.83672     0.440589
53          │    -1.41914     -1.29655         0.73416     0.750696
54          │    -2.42991    -0.616694         5.48929     0.420178
55          │    0.576874     -2.16508         5.38445    -0.644041
56          │    -4.29701      6.37822          6.1074      2.76758
57          │    -2.87993    -0.435745             NaN      3.09862
58          │    0.953847       1.8082  …      3.09862          NaN</code></pre></div><div><pre><code class="language-julia">ZBLMIp, BLMIp  = BLMI(msa)
ZBLMIp</code></pre><pre><code class="language-none">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │           15            16  …            57            58
────────────┼──────────────────────────────────────────────────────────
15          │          NaN    -0.0591238  …    -0.0363602    -0.0152761
16          │   -0.0591238           NaN       -0.0229516    0.00311181
17          │   -0.0173015    -0.0308905       -0.0017963    -0.0196877
18          │   0.00291386   -0.00274027          0.01618     0.0152826
19          │    -0.036221    -0.0377907        0.0847306   -0.00894515
20          │   -0.0521126   -0.00863729      -0.00286994    -0.0165979
21          │    0.0185897     -0.008631        0.0590086   -0.00869647
25          │   -0.0351687    -0.0520763       -0.0137703    -0.0621081
26          │   -0.0288024    -0.0533017       -0.0619708    -0.0398184
⋮                        ⋮             ⋮  ⋱             ⋮             ⋮
50          │     0.015389    -0.0123022        0.0266216    0.00581153
51          │   -0.0171912      0.126569         0.134359   -0.00460635
52          │     0.030577    -0.0169369       -0.0064634    -0.0133343
53          │   0.00373242   -0.00758101      0.000843295     0.0246918
54          │   -0.0152049   -0.00201109        0.0833894    0.00992427
55          │    0.0129841    -0.0448794        0.0527604    -0.0136904
56          │   -0.0438856      0.110146        0.0474788     0.0743159
57          │   -0.0363602    -0.0229516              NaN     0.0198315
58          │   -0.0152761    0.00311181  …     0.0198315           NaN</code></pre></div><h2><a class="nav-anchor" id="Visualize-Mutual-Information-1" href="#Visualize-Mutual-Information-1">Visualize Mutual Information</a></h2><p>You can use the function of the <code>Plots</code> package to visualize the Mutual Information (MI) network between residues. As an example, we are going to visualize the MI between residues of the Pfam domain <em>PF16078</em>. The <code>heatmap</code> is the simplest way to visualize the values of the Mutual Information matrix.  </p><div><pre><code class="language-julia">using Plots
pyplot()

heatmap(ZMIp, yflip=true)</code></pre></div><p><img src="inf_heatmap.png" alt/>   </p><p>ZMIp is a Z score of the corrected MIp against its distribution on a random MSA (shuffling the residues in each sequence), so pairs with highest values are more likely to co-evolve. Here, we are going to use the top 1% pairs of MSA columns.  </p><div><pre><code class="language-julia">using PairwiseListMatrices # to use getlist

threshold = quantile(getlist(ZMIp), 0.99)</code></pre><pre><code class="language-none">8.53438168905068</code></pre></div><div><pre><code class="language-julia">ZMIp[ ZMIp .&lt; threshold ] = NaN
heatmap(ZMIp, yflip=true)</code></pre></div><p><img src="inf_heatmap_top.png" alt/>   </p><p>We are going to calculate the cMI (cumulative mutual information) value of each node. Where cMI is a mutual information score per position that characterizes the extent of mutual information &quot;interactions&quot; in its neighbourhood. This score is calculated as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network and we are going to indicate it using the node color. To calculate cMI we are going to use the <code>cumulative</code> function:   </p><div><pre><code class="language-julia">cMI = cumulative(ZMIp, threshold)</code></pre><pre><code class="language-none">1×39 Named Array{Float64,2}
Function ╲ Col2 │      15       16       17  …       56       57       58
────────────────┼────────────────────────────────────────────────────────
cumulative      │     0.0      0.0      0.0  …  9.82675  9.10315      0.0</code></pre></div><p>The nodes have an order, because they are columns in a MSA. So, the <strong>arc diagram</strong> it&#39;s useful to visualize long and short association between MSA positions. In general, long interactions has more interest.</p><pre><code class="language-">using PlotRecipes

graphplot(ZMIp, size=(600,250), method=:arcdiagram) # , zcolor=cMI)
png(&quot;inf_arcdiagram.png&quot;) # hide
nothing # hide</code></pre><p><img src="inf_arcdiagram.png" alt/>   </p><p>You can also use a <strong>chord diagram</strong> to see the same pattern.  </p><pre><code class="language-">graphplot(ZMIp, size=(600,600), method=:chorddiagram)
png(&quot;inf_chorddiagram.png&quot;) # hide
nothing # hide</code></pre><p><img src="inf_chorddiagram.png" alt/>   </p><footer><hr/><a class="previous" href="MSA.html"><span class="direction">Previous</span><span class="title">MSA</span></a><a class="next" href="SIFTS.html"><span class="direction">Next</span><span class="title">SIFTS</span></a></footer></article></body></html>
