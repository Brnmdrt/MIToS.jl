<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MSA · MIToS</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIToS</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="Installation.html">Installation</a></li><li><a class="toctext" href="Example.html">Example</a></li><li><span class="toctext">Modules</span><ul><li class="current"><a class="toctext" href="MSA.html">MSA</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#MSA-IO-1">MSA IO</a></li><li><a class="toctext" href="#MSA-Annotations-1">MSA Annotations</a></li><li><a class="toctext" href="#Editing-your-MSA-1">Editing your MSA</a></li><li><a class="toctext" href="#Column-and-sequence-mappings-1">Column and sequence mappings</a></li><li><a class="toctext" href="#Get-sequences-from-a-MSA-1">Get sequences from a MSA</a></li><li><a class="toctext" href="#Describing-your-MSA-1">Describing your MSA</a></li><li><a class="toctext" href="#Sequence-clustering-1">Sequence clustering</a></li></ul></li><li><a class="toctext" href="Information.html">Information</a></li><li><a class="toctext" href="SIFTS.html">SIFTS</a></li><li><a class="toctext" href="PDB.html">PDB</a></li><li><a class="toctext" href="Pfam.html">Pfam</a></li></ul></li><li><a class="toctext" href="Scripts.html">Scripts</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="MSA_API.html">MSA</a></li><li><a class="toctext" href="Information_API.html">Information</a></li><li><a class="toctext" href="SIFTS_API.html">SIFTS</a></li><li><a class="toctext" href="PDB_API.html">PDB</a></li><li><a class="toctext" href="Pfam_API.html">Pfam</a></li><li><a class="toctext" href="Utils_API.html">Utils</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modules</li><li><a href="MSA.html">MSA</a></li></ul><a class="edit-page" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/MSA.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MSA</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Module-MSA-1" href="#Module-MSA-1">MSA</a></h1><p>The MSA module of MIToS has utilities for working with Multiple Sequence Alignments of protein Sequences (MSA).  </p><pre><code class="language-julia">using MIToS.MSA # to load the MSA module</code></pre><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><ul><li><p><a href="MSA.html#Reading-MSA-files-1"><strong>Read</strong></a> and <a href="MSA.html#Writing-MSA-files-1"><strong>write</strong></a> MSAs in <code>Stockholm</code>, <code>FASTA</code> or <code>Raw</code> format.</p></li><li><p>Handle <a href="MSA.html#MSA-Annotations-1"><strong>MSA annotations</strong></a>.</p></li><li><p><a href="MSA.html#Editing-your-MSA-1"><strong>Edit the MSA</strong></a>, e.g. delete columns or sequences, change sequence order, shuffling...</p></li><li><p><a href="MSA.html#Column-and-sequence-mappings-1"><strong>Keep track of positions</strong></a> and annotations after modifications on the MSA.</p></li><li><p><a href="MSA.html#Describing-your-MSA-1"><strong>Describe an MSA</strong></a>, e.g. mean percent identity, sequence coverage, gap percentage...</p></li><li><p><a href="MSA.html#Sequence-clustering-1"><strong>Sequence clustering</strong></a> with Hobohm I.</p></li></ul><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="MSA.html#Module-MSA-1">MSA</a></li><ul><li><a href="MSA.html#Features-1">Features</a></li><li><a href="MSA.html#Contents-1">Contents</a></li><li><a href="MSA.html#MSA-IO-1">MSA IO</a></li><ul><li><a href="MSA.html#Reading-MSA-files-1">Reading MSA files</a></li><li><a href="MSA.html#Writing-MSA-files-1">Writing MSA files</a></li></ul><li><a href="MSA.html#MSA-Annotations-1">MSA Annotations</a></li><li><a href="MSA.html#Editing-your-MSA-1">Editing your MSA</a></li><ul><ul><li><a href="MSA.html#Example:-Deleting-sequences-1">Example: Deleting sequences</a></li><li><a href="MSA.html#Example:-Exporting-a-MSA-for-freecontact-(part-I)-1">Example: Exporting a MSA for freecontact (part I)</a></li></ul></ul><li><a href="MSA.html#Column-and-sequence-mappings-1">Column and sequence mappings</a></li><ul><ul><li><a href="MSA.html#Example:-Exporting-a-MSA-for-freecontact-(part-II)-1">Example: Exporting a MSA for freecontact (part II)</a></li></ul></ul><li><a href="MSA.html#Get-sequences-from-a-MSA-1">Get sequences from a MSA</a></li><li><a href="MSA.html#Describing-your-MSA-1">Describing your MSA</a></li><ul><ul><li><a href="MSA.html#Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence-1">Example: Plotting gap percentage per column and coverage per sequence</a></li><li><a href="MSA.html#Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction-1">Example: Filter sequences per coverage and columns per gap fraction</a></li><li><a href="MSA.html#Example:-Plotting-the-percentage-of-identity-between-sequences-1">Example: Plotting the percentage of identity between sequences</a></li></ul></ul><li><a href="MSA.html#Sequence-clustering-1">Sequence clustering</a></li><ul><ul><li><a href="MSA.html#Example:-Reducing-redundancy-of-a-MSA-1">Example: Reducing redundancy of a MSA</a></li></ul></ul></ul></ul><h2><a class="nav-anchor" id="MSA-IO-1" href="#MSA-IO-1">MSA IO</a></h2><h3><a class="nav-anchor" id="Reading-MSA-files-1" href="#Reading-MSA-files-1">Reading MSA files</a></h3><p>The main function for reading MSA files in MIToS is <code>read</code> and it is defined in the <code>Utils</code> module. This function takes a filename/path as a first argument followed by other arguments. It opens the file and uses the arguments to call the <code>parse</code> function. <code>read</code> decides how to open the file, using the prefixes and suffixes of the file name, while <code>parse</code> does the actual parsing of the file. You can <code>read</code> <strong>gzipped files</strong> if they have the <code>.gz</code> extension and also urls pointing to a <strong>web file</strong>.   The second argument of <code>read</code> and <code>parse</code> is the file <code>Format</code>. The supported MSA formats at the moment are <code>Stockholm</code>, <code>FASTA</code> and <code>Raw</code>.   For example, reading with MIToS the full Stockholm MSA of the family PF07388 using the Pfam RESTful interface will be:  </p><div><pre><code class="language-julia">using MIToS.MSA

read(&quot;http://pfam.xfam.org/family/PF07388/alignment/full&quot;, Stockholm)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 28 annotations : 7×459 Named Array{MIToS.MSA.Residue,2}
               Seq ╲ Col │  23   24   25   26   27  …  522  523  524  525  526
─────────────────────────┼────────────────────────────────────────────────────
M5A3D2_9ACTN/208-402     │   -    -    -    -    -  …    -    -    -    -    -
Q4W584_NEIMB/1-222       │   M    L    K    K    I       -    -    -    -    -
C5ZW53_9HELI/1-498       │   -    -    K    K    L       K    Y    L    Q    L
M5A3D2_9ACTN/2-157       │   -    -    -    -    -       -    -    -    -    -
A0A157SWM6_9BORD/1-413   │   -    L    K    K    L       -    -    -    -    -
A0A0B0IGB5_9BACI/201-416 │   -    -    -    -    -       -    -    -    -    -
A0A0B0IGB5_9BACI/1-170   │   -    -    -    -    -  …    -    -    -    -    -</code></pre></div><p>The third (and optional) argument of <code>read</code> and <code>parse</code> is the output MSA type:  </p><ul><li><p><code>Matrix{Residue}</code> : It contains the aligned sequences.  </p></li><li><p><code>MultipleSequenceAlignment</code> : It contains the aligned sequences and their</p></li></ul><p>names/identifiers.  </p><ul><li><p><code>AnnotatedMultipleSequenceAlignment</code> : Is the richest MSA format of MIToS. It&#39;s the</p></li></ul><p>default. It includes the aligned sequences, their names and the MSA annotations.  </p><p>Example of <code>Matrix{Residue}</code> output using a <code>Stockholm</code> file as input:</p><div><pre><code class="language-julia">read(&quot;http://pfam.xfam.org/family/PF07388/alignment/full&quot;, Stockholm, Matrix{Residue})</code></pre><pre><code class="language-none">7×459 Array{MIToS.MSA.Residue,2}:
 -  -  -  -  -  -  -  -  -  -  -  -  -  …  -  -  -  -  -  -  -  -  -  -  -  -
 M  L  K  K  I  K  K  A  L  F  Q  P  K     -  -  -  -  -  -  -  -  -  -  -  -
 -  -  K  K  L  S  G  L  M  Q  D  I  K     D  F  Q  K  Y  R  I  K  Y  L  Q  L
 -  -  -  -  -  -  -  -  -  -  -  -  -     -  -  -  -  -  -  -  -  -  -  -  -
 -  L  K  K  L  R  K  L  I  L  H  P  V     -  -  -  -  -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -  -  -  -  -  -  …  -  -  -  -  -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  -  -  -  -  -  -     -  -  -  -  -  -  -  -  -  -  -  -</code></pre></div><p>Given that <code>read</code> calls <code>parse</code>, you should look into the documentation of the last one to know the available keyword arguments. The optional keyword arguments of those functions are:  </p><ul><li><p><code>generatemapping</code> : If <code>generatemapping</code> is <code>true</code> (default: <code>false</code>), sequences and</p></li></ul><p>columns mappings are generated and saved in the MSA annotations. <strong>The default is <code>false</code> to not overwrite mappings by mistake when you read an annotated MSA file saved with MIToS.</strong>  </p><ul><li><p><code>useidcoordinates</code> : If <code>useidcoordinates</code> is <code>true</code> (default: <code>false</code>) and the names</p></li></ul><p>have the form <em>seqname/start-end</em>, MIToS uses this coordinates to generate sequence mappings. This is safe and useful with unmodified Pfam MSAs. <strong>Do not use it when reading an MSA saved with MIToS. MIToS deletes unaligned insert columns, therefore disrupts sequences that have them.</strong>  </p><ul><li><p><code>deletefullgaps</code> : Given that lowercase characters and dots are converted to gaps,</p></li></ul><p>unaligned insert columns in the MSA (derived from a HMM profile) are converted into full gap columns. <code>deletefullgaps</code> is <code>true</code> by default, deleting full gaps columns and therefore insert columns.  </p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>If you want to keep the insert columns...</strong>  Use the keyword argument <code>keepinserts</code> to <code>true</code> in <code>read</code>/<code>parse</code>. This only works with an <code>AnnotatedMultipleSequenceAlignment</code> output. A column annotation (<code>&quot;Aligned&quot;</code>) is stored in the annotations, where insert columns are marked with <code>0</code> and aligned columns with <code>1</code>.  </p></div></div><p>When <code>read</code> returns an <code>AnnotatedMultipleSequenceAlignment</code>, it uses the MSA <code>Annotations</code> to keep track of performed modifications. To access this notes, use <code>printmodifications</code>:  </p><div><pre><code class="language-julia">msa = read(&quot;http://pfam.xfam.org/family/PF01565/alignment/full&quot;, Stockholm)

printmodifications(msa)</code></pre><pre><code class="language-none">-------------------
2017-10-16T14:47:08.75

deletefullgaps!  :  Deletes 746 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
-------------------
2017-10-16T14:47:08.78

filtercolumns! : 746 columns have been deleted.</code></pre></div><h3><a class="nav-anchor" id="Writing-MSA-files-1" href="#Writing-MSA-files-1">Writing MSA files</a></h3><p>Julia REPL shows MSAs as Matrices. If you want to print them in another format, you should use the <code>print</code> function with an MSA object as first argument and the <code>Format</code> <code>FASTA</code>, <code>Stockholm</code> or <code>Raw</code> as second argument.  </p><div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF16996/alignment/full&quot;, Stockholm) # reads a Stockholm MSA file

print(msa, FASTA) # prints msa in FASTA format</code></pre><pre><code class="language-none">&gt;A0A139NMD7_9STRE/4-59
KDDIFYKDIEGRMDELKRKPPKKEKKTRAERISTFFSVSLGLVILIGLLFTLFRI
&gt;A0A139NPI6_9STRE/5-59
-EDLFYKEVEGRMADLQQKAPEKEKKTGAERLNTLFSLALGLVILLGLLFTLLR-
&gt;J0UVX5_STREE/3-39
-EDLFYKDVEGRMEELKQKPIKKEKKP----------------------------
&gt;A0A139NTT2_9STRE/3-57
KKDLFYKDVEQKLDSLKQGQPKKEKASLGEKLNKAFVIALGLVILIGLIFTLI--
&gt;A3CM62_STRSV/3-57
KKDLFYKDIEGRLDELKHGKPKKEKASLGENLNKAFVIVLGLMILIGLIFTLI--
&gt;T0TY77_9STRE/5-59
KKDLFYKEVEGRMESLKRRPAEKEKTTRSEKINVTFNVIIGLVILLGVIFTLFRV</code></pre></div><p>To save an MSA object to a file, use the <code>write</code> function. This function takes a filename as a first argument. If the filename ends with <code>.gz</code>, the output will be a compressed (gzipped) file. The next two arguments of <code>write</code> are passed to <code>print</code>, so <code>write</code> behaves as <code>print</code>.  </p><div><pre><code class="language-julia">write(&quot;msa.gz&quot;, msa, FASTA) # writes msa in FASTA format in a gzipped file</code></pre></div><h2><a class="nav-anchor" id="MSA-Annotations-1" href="#MSA-Annotations-1">MSA Annotations</a></h2><p>MSA annotations are based on the Stockholm format mark-ups. There are four types of annotations stored as dictionaries. All the annotations have a feature name as part of the key, which should be a single &quot;word&quot; (without spaces) and less than 50 characters long.  </p><ul><li><p><strong>File annotations</strong> : The annotations can contain either file or MSA information. They</p></li></ul><p>have feature names as keys and the values are strings (free text). Lines starting with <code>#=GF</code> in Stockholm format.  </p><ul><li><p><strong>Column annotations</strong> : They have feature names as keys and strings with exactly 1 char</p></li></ul><p>per column as values. Lines starting with <code>#=GC</code> in Stockholm format.  </p><ul><li><p><strong>Sequence annotations</strong> : The keys are tuples with the sequence name and the feature</p></li></ul><p>name. The values are free text (strings). Lines starting with <code>#=GS</code> in Stockholm format.  </p><ul><li><p><strong>Residue annotations</strong> : The keys are tuples with the sequence name and the feature</p></li></ul><p>name. The values are strings with exactly 1 char per column/residues. <code>#=GR</code> lines in Stockholm format.  </p><p>Julia REPL shows the <code>Annotations</code> type as they are represented in the <a href="https://en.wikipedia.org/wiki/Stockholm_format">Stockholm format<img src="assets/external-link.png" alt/></a>. You can get the <code>Annotations</code> inside an annotated MSA or sequence using the <code>annotations</code> function.  </p><div><pre><code class="language-julia">annotations(msa)</code></pre><pre><code class="language-none">#=GF ID	Asp4
#=GF AC	PF16996.4
#=GF DE	Accessory secretory protein Sec Asp4
#=GF AU	Coggill P
#=GF SE	Pfam-B_7603 (release 27.0)
#=GF GA	25.70 25.70;
#=GF TC	26.50 37.80;
#=GF NC	21.60 20.60;
#=GF BM	hmmbuild HMM.ann SEED.ann
#=GF SM	hmmsearch -Z 26740544 -E 1000 --cpu 4 HMM pfamseq
#=GF TP	Family
#=GF RN	[1]
#=GF RM	23000954
#=GF RT	Emerging themes in SecA2-mediated protein export.
#=GF RA	Feltcher ME, Braunstein M;
#=GF RL	Nat Rev Microbiol. 2012;10:779-789.
#=GF DR	INTERPRO; IPR031551;
#=GF CC	Asp4 and Asp5 are putative accessory components of the SecY2
#=GF CC	channel of the SecA2-SecY2 mediated export system, but they are
#=GF CC	not present in all SecA2-SecY2 systems. This family of Asp4 is
#=GF CC	found in Firmicutes [1].
#=GF SQ	6
#=GF MIToS_2017-10-16T14:47:09.418	deletefullgaps!  :  Deletes 11 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
#=GF MIToS_2017-10-16T14:47:09.418	filtercolumns! : 11 columns have been deleted.
#=GS A3CM62_STRSV/3-57	AC	A3CM62.1
#=GS A0A139NTT2_9STRE/3-57	AC	A0A139NTT2.1
#=GS A0A139NMD7_9STRE/4-59	AC	A0A139NMD7.1
#=GS J0UVX5_STREE/3-39	AC	J0UVX5.1
#=GS T0TY77_9STRE/5-59	AC	T0TY77.1
#=GS A0A139NPI6_9STRE/5-59	AC	A0A139NPI6.1
#=GC seq_cons			KcDLFYKDVEGRM--LKp+sPKKEKpohuE+lNphFslsLGLVILlGLlFTLh..</code></pre></div><p>Particular annotations can be accessed using the functions <code>getannot...</code>. This functions take the MSA/sequence as first argument and the feature name of the desired annotation as the last. In the case of <code>getannotsequence</code> and <code>getannotresidue</code>, the second argument should be the sequence name.  </p><div><pre><code class="language-julia">getannotsequence(msa, &quot;J0UVX5_STREE/3-39&quot;, &quot;AC&quot;) # (&quot;J0UVX5_STREE/3-39&quot;, &quot;AC&quot;) is the key in the dictionary</code></pre><pre><code class="language-none">&quot;J0UVX5.1&quot;</code></pre></div><p>If you want to add new annotations, you should use the <code>setannot…!</code> functions. This functions have the same arguments that <code>getannot...</code> functions but with an extra argument to indicate the new annotation.  </p><div><pre><code class="language-julia">setannotsequence!(msa, &quot;J0UVX5_STREE/3-39&quot;, &quot;New_Feature_Name&quot;, &quot;New_Annotation&quot;)</code></pre><pre><code class="language-none">&quot;New_Annotation&quot;</code></pre></div><p>A <code>getannot...</code> function without the key (last arguments), returns the particular annotation dictionary. As you can see, the new sequence annotation is now part of our MSA annotations.  </p><div><pre><code class="language-julia">getannotsequence(msa)</code></pre><pre><code class="language-none">Dict{Tuple{String,String},String} with 7 entries:
  (&quot;A3CM62_STRSV/3-57&quot;, &quot;AC&quot;)               =&gt; &quot;A3CM62.1&quot;
  (&quot;A0A139NTT2_9STRE/3-57&quot;, &quot;AC&quot;)           =&gt; &quot;A0A139NTT2.1&quot;
  (&quot;A0A139NMD7_9STRE/4-59&quot;, &quot;AC&quot;)           =&gt; &quot;A0A139NMD7.1&quot;
  (&quot;J0UVX5_STREE/3-39&quot;, &quot;New_Feature_Name&quot;) =&gt; &quot;New_Annotation&quot;
  (&quot;J0UVX5_STREE/3-39&quot;, &quot;AC&quot;)               =&gt; &quot;J0UVX5.1&quot;
  (&quot;T0TY77_9STRE/5-59&quot;, &quot;AC&quot;)               =&gt; &quot;T0TY77.1&quot;
  (&quot;A0A139NPI6_9STRE/5-59&quot;, &quot;AC&quot;)           =&gt; &quot;A0A139NPI6.1&quot;</code></pre></div><h2><a class="nav-anchor" id="Editing-your-MSA-1" href="#Editing-your-MSA-1">Editing your MSA</a></h2><p>MIToS offers functions to edit your MSA. Given that this functions modify the msa, their names end with a bang <code>!</code>, following the Julia convention. Some of these functions have an <code>annotate</code> keyword argument (in general it is <code>true</code> by default) to indicate if the modification should be recorded in the MSA/sequence annotations.  </p><p>One common task is to delete sequences or columns of the MSA. This could be done using the functions <code>filtersequences!</code> and <code>filtercolumns!</code>. This functions take the MSA or sequence (if it&#39;s possible) as first argument and a <code>BitVector</code> or <code>Vector{Bool}</code> mask as second argument. It deletes all the sequences or columns where the mask is <code>false</code>. This functions are also defined for <code>Annotations</code>, this allows to automatically update (modify) the annotations (and therefore, sequence and column mappings) in the MSA.  </p><p>This two deleting operations are used in the second and third mutating functions of the following list:  </p><ul><li><p><code>setreference!</code> : Sets one of the sequences as the first sequence of the MSA (query or</p></li></ul><p>reference sequence).  </p><ul><li><p><code>adjustreference!</code> : Deletes columns with gaps in the first sequence of the MSA</p></li></ul><p>(reference).  </p><ul><li><p><code>gapstrip!</code> : This function first calls <code>adjustreference!</code>, then deletes sequences with</p></li></ul><p>low (user defined) MSA coverage and finally, columns with user defined % of gaps.  </p><p>Also, there are several available funtions <code>shuffle_…!</code>. These functions are useful to generate random alignments. The <code>Information</code> module of <code>MIToS</code> uses them to calculate the Z scores of MI values.  </p><h4><a class="nav-anchor" id="Example:-Deleting-sequences-1" href="#Example:-Deleting-sequences-1">Example: Deleting sequences</a></h4><p>For example, if you want to keep only the proteins from <em>Actinobacteria</em> you can delete all the sequences that don&#39;t have <code>_9ACTN</code> in their UniProt entry names:  </p><div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF07388/alignment/full&quot;, Stockholm)

sequencenames(msa) # the function sequencenames returns the sequence names in the MSA</code></pre><pre><code class="language-none">7-element Array{String,1}:
 &quot;M5A3D2_9ACTN/208-402&quot;
 &quot;Q4W584_NEIMB/1-222&quot;
 &quot;C5ZW53_9HELI/1-498&quot;
 &quot;M5A3D2_9ACTN/2-157&quot;
 &quot;A0A157SWM6_9BORD/1-413&quot;
 &quot;A0A0B0IGB5_9BACI/201-416&quot;
 &quot;A0A0B0IGB5_9BACI/1-170&quot;</code></pre></div><div><pre><code class="language-julia">mask = map(x -&gt; ismatch(r&quot;_9ACTN&quot;, x), sequencenames(msa)) # an element of mask is true if &quot;_9ACTN&quot; is in the name</code></pre><pre><code class="language-none">7-element Array{Bool,1}:
  true
 false
 false
  true
 false
 false
 false</code></pre></div><div><pre><code class="language-julia">filtersequences!(msa, mask) # deletes all the sequences where mask is false

sequencenames(msa)</code></pre><pre><code class="language-none">2-element Array{String,1}:
 &quot;M5A3D2_9ACTN/208-402&quot;
 &quot;M5A3D2_9ACTN/2-157&quot;</code></pre></div><h4><a class="nav-anchor" id="Example:-Exporting-a-MSA-for-freecontact-(part-I)-1" href="#Example:-Exporting-a-MSA-for-freecontact-(part-I)-1">Example: Exporting a MSA for freecontact (part I)</a></h4><p>The most simple input for the command line tool <a href="https://rostlab.org/owiki/index.php/FreeContact">freecontact<img src="assets/external-link.png" alt/></a> (if you don&#39;t want to set <code>--mincontsep</code>) is a <code>Raw</code> MSA file with a reference sequence without insertions or gaps. This is easy to get with MIToS using <code>read</code> (deletes the insert columns), <code>setreference!</code> (to choose a reference), <code>adjustreference!</code> (to delete columns with gaps in the reference) and <code>write</code> (to save it in <code>Raw</code> format) functions.  </p><pre><code class="language-julia-repl">julia&gt; using MIToS.MSA

julia&gt; msa = read(&quot;http://pfam.xfam.org/family/PF02476/alignment/full&quot;, Stockholm)
AnnotatedMultipleSequenceAlignment with 24 annotations : 3×126 Named Array{MIToS.MSA.Residue,2}
         Seq ╲ Col │   2    3    4    5    6  …  140  141  142  143  144
───────────────────┼────────────────────────────────────────────────────
US02_GAHVM/120-237 │   M    L    E    S    E  …    F    C    C    -    -
US02_HHV2H/110-246 │   L    L    H    Q    E       P    C    F    T    C
US02_HHV11/110-247 │   -    L    H    R    D  …    P    C    C    A    C

julia&gt; maxcoverage, indice = findmax(coverage(msa)) # chooses the sequence with more coverage of the MSA
(0.9841269841269842, 2)

julia&gt; setreference!(msa, indice)
AnnotatedMultipleSequenceAlignment with 25 annotations : 3×126 Named Array{MIToS.MSA.Residue,2}
         Seq ╲ Col │   2    3    4    5    6  …  140  141  142  143  144
───────────────────┼────────────────────────────────────────────────────
US02_HHV2H/110-246 │   L    L    H    Q    E  …    P    C    F    T    C
US02_GAHVM/120-237 │   M    L    E    S    E       F    C    C    -    -
US02_HHV11/110-247 │   -    L    H    R    D  …    P    C    C    A    C

julia&gt; adjustreference!(msa)
AnnotatedMultipleSequenceAlignment with 26 annotations : 3×124 Named Array{MIToS.MSA.Residue,2}
         Seq ╲ Col │   2    3    4    5    6  …  140  141  142  143  144
───────────────────┼────────────────────────────────────────────────────
US02_HHV2H/110-246 │   L    L    H    Q    E  …    P    C    F    T    C
US02_GAHVM/120-237 │   M    L    E    S    E       F    C    C    -    -
US02_HHV11/110-247 │   -    L    H    R    D  …    P    C    C    A    C

julia&gt; write(&quot;tofreecontact.msa&quot;, msa, Raw)

julia&gt; print(readstring(&quot;tofreecontact.msa&quot;)) # It displays the contents of the output file
LLHQERPGPRLYHLWVVGAADLCVPFFEYAQKTRRFIATKTNDAWVGEPWPLPDRFLPERTVSWTPFPAAPNHPLENLLSRYEYQYGVVVPRWLRSLVAPHKPRPASSRPHPATHPTQRPCFTC
MLESEVSGNAPHSLWIVGAADICRIALECIPLPKRLLAIKVSGTWSGMPWAIPDNIQTLLTSTWEPKFDTPEDRAHFCDSDMVCVYKILGS----------PPNPLKPPEIEPPQMGRLFCC--
-LHRDQPSPRLYHLWVVGAADLCVPFLEYAQKIRRFIAIKTPDAWVGEPWAVPTRFLPEWTVAWTPFPAAPNHPLETLLSRYEYQYGVVLPRWLRSLIALHKPHPATPGPLTTSHPVRRPCCAC</code></pre><h2><a class="nav-anchor" id="Column-and-sequence-mappings-1" href="#Column-and-sequence-mappings-1">Column and sequence mappings</a></h2><p>Inserts in a Stockholm MSA allow to access the full fragment of the aligned sequences. Using this, combined with the sequence names with coordinates used in Pfam, you can know what is the UniProt residue number of each residue in the MSA.   </p><pre><code class="language-julia">&quot;PROT_SPECI/3-15 .....insertALIGNED&quot;
#                     3456789111111
#                            012345</code></pre><p>MIToS <code>read</code> and <code>parse</code> functions deletes the insert columns, but they do the mapping of each residue to its residue number before deleting insert columns if <code>generatemapping</code> is <code>true</code>. If you don&#39;t set <code>useidcoordinates</code> to <code>true</code>, the residue first <code>i</code> residue will be 1 instead of 3 in the previous example.  </p><div><pre><code class="language-julia">using MIToS.MSA

msa = parse(&quot;PROT_SPECI/3-15 .....insertALIGNED&quot;, Stockholm, generatemapping=true, useidcoordinates=true)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 5 annotations : 1×7 Named Array{MIToS.MSA.Residue,2}
      Seq ╲ Col │ 12  13  14  15  16  17  18
────────────────┼───────────────────────────
PROT_SPECI/3-15 │  A   L   I   G   N   E   D</code></pre></div><p>MIToS also keeps the column number of the input MSA and its total number of columns. All this data is stored in the MSA annotations using the <code>SeqMap</code>, <code>ColMap</code> and <code>NCol</code> feature names.  </p><div><pre><code class="language-julia">annotations(msa)</code></pre><pre><code class="language-none">#=GF NCol	18
#=GF ColMap	12,13,14,15,16,17,18
#=GF MIToS_2017-10-16T14:47:14.751	deletefullgaps!  :  Deletes 11 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
#=GF MIToS_2017-10-16T14:47:14.759	filtercolumns! : 11 columns have been deleted.
#=GS PROT_SPECI/3-15	SeqMap	9,10,11,12,13,14,15</code></pre></div><p>To have an easy access to mapping data, MIToS provides the <code>getsequencemapping</code> and <code>getcolumnmapping</code> functions.  </p><div><pre><code class="language-julia">getsequencemapping(msa, &quot;PROT_SPECI/3-15&quot;)</code></pre><pre><code class="language-none">7-element Array{Int64,1}:
  9
 10
 11
 12
 13
 14
 15</code></pre></div><div><pre><code class="language-julia">getcolumnmapping(msa)</code></pre><pre><code class="language-none">7-element Array{Int64,1}:
 12
 13
 14
 15
 16
 17
 18</code></pre></div><h4><a class="nav-anchor" id="Example:-Exporting-a-MSA-for-freecontact-(part-II)-1" href="#Example:-Exporting-a-MSA-for-freecontact-(part-II)-1">Example: Exporting a MSA for freecontact (part II)</a></h4><p>If we want to use the <code>--mincontsep</code> argument of <code>freecontact</code> to calculate scores between distant residues, we will need to add a header to the MSA. This header should contains the residue number of the first residue of the sequence and the full fragment of that sequence (with the inserts). This data is used by FreeContact to calculate the residue number of each residue in the reference sequence.   We are going to use MIToS mapping data to create this header, so we read the MSA with <code>generatemapping</code> and <code>useidcoordinates</code> setted to <code>true</code>.  </p><div><pre><code class="language-julia">using MIToS.MSA

msa = read( &quot;http://pfam.xfam.org/family/PF02476/alignment/full&quot;, Stockholm,
            generatemapping=true, useidcoordinates=true)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 29 annotations : 3×126 Named Array{MIToS.MSA.Residue,2}
         Seq ╲ Col │   2    3    4    5    6  …  140  141  142  143  144
───────────────────┼────────────────────────────────────────────────────
US02_GAHVM/120-237 │   M    L    E    S    E  …    F    C    C    -    -
US02_HHV2H/110-246 │   L    L    H    Q    E       P    C    F    T    C
US02_HHV11/110-247 │   -    L    H    R    D  …    P    C    C    A    C</code></pre></div><p>Here, we are going to choose the sequence with more coverage of the MSA as our reference sequence.  </p><div><pre><code class="language-julia">maxcoverage, indice = findmax(coverage(msa))
setreference!(msa, indice)
adjustreference!(msa)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 31 annotations : 3×124 Named Array{MIToS.MSA.Residue,2}
         Seq ╲ Col │   2    3    4    5    6  …  140  141  142  143  144
───────────────────┼────────────────────────────────────────────────────
US02_HHV2H/110-246 │   L    L    H    Q    E  …    P    C    F    T    C
US02_GAHVM/120-237 │   M    L    E    S    E       F    C    C    -    -
US02_HHV11/110-247 │   -    L    H    R    D  …    P    C    C    A    C</code></pre></div><p>MIToS deletes the residues in insert columns, so we are going to use the sequence mapping to generate the whole fragment of the reference sequence (filling the missing regions with <code>&#39;x&#39;</code>).  </p><div><pre><code class="language-julia">seqmap = getsequencemapping(msa, 1) # seqmap will be a vector with the residue numbers of the first sequence (reference)

seq = collect( stringsequence(msa, 1) ) # seq will be a Vector of Chars with the reference sequence

sequence = map(seqmap[1]:seqmap[end]) do seqpos # for each position in the whole fragment
    if seqpos in seqmap                         # if that position is in the MSA
        shift!(seq)                             # the residue is taken from seq
    else                                        # otherwise
        &#39;x&#39;                                     # &#39;x&#39; is included
    end
end

sequence = join(sequence) # join the Chars on the Vector to create a string</code></pre><pre><code class="language-none">&quot;LLHQERPGPxRLYHLWVVGAADLCVPFFEYAQKTRxxxRFIATKTNDAWVGEPWPLPDRFLPERTVSWTPFPAAPNHPLENLLSRYEYQYGVVVPxxxxxxxxRWLRSLVAPHxKPRPASSRPHPATHPTQRPCFTC&quot;</code></pre></div><p>Once we have the whole fragment of the sequence, we create the file and write the header in the required format (as in the man page of freecontact).  </p><div><pre><code class="language-julia">open(&quot;tofreecontact.msa&quot;, &quot;w&quot;) do fh

    println(fh, &quot;# querystart=&quot;, seqmap[1])

    println(fh, &quot;# query=&quot;, sequence )

end</code></pre></div><p>As last (optional) argument, <code>write</code> takes the mode in which is opened the file. We use <code>&quot;a&quot;</code> here to append the MSA to the header.  </p><div><pre><code class="language-julia">write(&quot;tofreecontact.msa&quot;, msa, Raw, &quot;a&quot;)</code></pre></div><div><pre><code class="language-julia">print(readstring(&quot;tofreecontact.msa&quot;)) # It displays the contents of the output file</code></pre><pre><code class="language-none"># querystart=110
# query=LLHQERPGPxRLYHLWVVGAADLCVPFFEYAQKTRxxxRFIATKTNDAWVGEPWPLPDRFLPERTVSWTPFPAAPNHPLENLLSRYEYQYGVVVPxxxxxxxxRWLRSLVAPHxKPRPASSRPHPATHPTQRPCFTC
LLHQERPGPRLYHLWVVGAADLCVPFFEYAQKTRRFIATKTNDAWVGEPWPLPDRFLPERTVSWTPFPAAPNHPLENLLSRYEYQYGVVVPRWLRSLVAPHKPRPASSRPHPATHPTQRPCFTC
MLESEVSGNAPHSLWIVGAADICRIALECIPLPKRLLAIKVSGTWSGMPWAIPDNIQTLLTSTWEPKFDTPEDRAHFCDSDMVCVYKILGS----------PPNPLKPPEIEPPQMGRLFCC--
-LHRDQPSPRLYHLWVVGAADLCVPFLEYAQKIRRFIAIKTPDAWVGEPWAVPTRFLPEWTVAWTPFPAAPNHPLETLLSRYEYQYGVVLPRWLRSLIALHKPHPATPGPLTTSHPVRRPCCAC</code></pre></div><h2><a class="nav-anchor" id="Get-sequences-from-a-MSA-1" href="#Get-sequences-from-a-MSA-1">Get sequences from a MSA</a></h2><p>It&#39;s possible to index the MSA as any other matrix to get an aligned sequence. This will be return a <code>Array</code> of <code>Residue</code>s without annotations but keeping names/identifiers.  </p><div><pre><code class="language-julia">using MIToS.MSA

msa = read( &quot;http://pfam.xfam.org/family/PF16996/alignment/full&quot;, Stockholm,
            generatemapping=true, useidcoordinates=true)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 36 annotations : 6×55 Named Array{MIToS.MSA.Residue,2}
            Seq ╲ Col │  2   3   4   5   6   7  …  51  52  53  54  55  56
──────────────────────┼──────────────────────────────────────────────────
A0A139NMD7_9STRE/4-59 │  K   D   D   I   F   Y  …   F   T   L   F   R   I
A0A139NPI6_9STRE/5-59 │  -   E   D   L   F   Y      F   T   L   L   R   -
J0UVX5_STREE/3-39     │  -   E   D   L   F   Y      -   -   -   -   -   -
A0A139NTT2_9STRE/3-57 │  K   K   D   L   F   Y      F   T   L   I   -   -
A3CM62_STRSV/3-57     │  K   K   D   L   F   Y      F   T   L   I   -   -
T0TY77_9STRE/5-59     │  K   K   D   L   F   Y  …   F   T   L   F   R   V</code></pre></div><div><pre><code class="language-julia">msa[2,:] # second sequence of the MSA, it keeps column names</code></pre><pre><code class="language-none">55-element Named Array{MIToS.MSA.Residue,1}
Col  │
─────┼──
2    │ -
3    │ E
4    │ D
5    │ L
6    │ F
7    │ Y
8    │ K
9    │ E
10   │ V
⋮      ⋮
48   │ G
49   │ L
50   │ L
51   │ F
52   │ T
53   │ L
54   │ L
55   │ R
56   │ -</code></pre></div><div><pre><code class="language-julia">msa[2:2,:] # Using the range 2:2 to select the second sequence, keeping the sequence name</code></pre><pre><code class="language-none">1×55 Named Array{MIToS.MSA.Residue,2}
            Seq ╲ Col │  2   3   4   5   6   7  …  51  52  53  54  55  56
──────────────────────┼──────────────────────────────────────────────────
A0A139NPI6_9STRE/5-59 │  -   E   D   L   F   Y  …   F   T   L   L   R   -</code></pre></div><p>If you want to obtain the aligned sequence with its name and annotations (and therefore sequence and column mappings), you should use the function <code>getsequence</code>. This function returns an <code>AlignedSequence</code> with the sequence name from a <code>MultipleSequenceAlignment</code> or an <code>AnnotatedAlignedSequence</code>, that also contains annotations, from an <code>AnnotatedMultipleSequenceAlignment</code>.  </p><div><pre><code class="language-julia">secondsequence = getsequence(msa, 2)</code></pre><pre><code class="language-none">AnnotatedAlignedSequence with 26 annotations : 1×55 Named Array{MIToS.MSA.Residue,2}
            Seq ╲ Col │  2   3   4   5   6   7  …  51  52  53  54  55  56
──────────────────────┼──────────────────────────────────────────────────
A0A139NPI6_9STRE/5-59 │  -   E   D   L   F   Y  …   F   T   L   L   R   -</code></pre></div><div><pre><code class="language-julia">annotations(secondsequence)</code></pre><pre><code class="language-none">#=GF ID	Asp4
#=GF AC	PF16996.4
#=GF DE	Accessory secretory protein Sec Asp4
#=GF AU	Coggill P
#=GF SE	Pfam-B_7603 (release 27.0)
#=GF GA	25.70 25.70;
#=GF TC	26.50 37.80;
#=GF NC	21.60 20.60;
#=GF BM	hmmbuild HMM.ann SEED.ann
#=GF SM	hmmsearch -Z 26740544 -E 1000 --cpu 4 HMM pfamseq
#=GF TP	Family
#=GF RN	[1]
#=GF RM	23000954
#=GF RT	Emerging themes in SecA2-mediated protein export.
#=GF RA	Feltcher ME, Braunstein M;
#=GF RL	Nat Rev Microbiol. 2012;10:779-789.
#=GF DR	INTERPRO; IPR031551;
#=GF CC	Asp4 and Asp5 are putative accessory components of the SecY2
#=GF CC	channel of the SecA2-SecY2 mediated export system, but they are
#=GF CC	not present in all SecA2-SecY2 systems. This family of Asp4 is
#=GF CC	found in Firmicutes [1].
#=GF SQ	6
#=GF NCol	66
#=GF ColMap	2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56
#=GF MIToS_2017-10-16T14:47:16.206	deletefullgaps!  :  Deletes 11 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
#=GF MIToS_2017-10-16T14:47:16.207	filtercolumns! : 11 columns have been deleted.
#=GS A0A139NPI6_9STRE/5-59	SeqMap	,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,
#=GS A0A139NPI6_9STRE/5-59	AC	A0A139NPI6.1
#=GC seq_cons			KcDLFYKDVEGRM--LKp+sPKKEKpohuE+lNphFslsLGLVILlGLlFTLh..</code></pre></div><p>Use <code>stringsequence</code> if you want to get the sequence as a string.  </p><div><pre><code class="language-julia">stringsequence(msa, 2)</code></pre><pre><code class="language-none">&quot;-EDLFYKEVEGRMADLQQKAPEKEKKTGAERLNTLFSLALGLVILLGLLFTLLR-&quot;</code></pre></div><p>Given that matrices are stored columnwise in Julia, you will find useful the <code>getresiduesequences</code> function when you need to heavily operate over sequences.  </p><div><pre><code class="language-julia">getresiduesequences(msa)</code></pre><pre><code class="language-none">6-element Array{Array{MIToS.MSA.Residue,1},1}:
 MIToS.MSA.Residue[K, D, D, I, F, Y, K, D, I, E  …  I, G, L, L, F, T, L, F, R, I]
 MIToS.MSA.Residue[-, E, D, L, F, Y, K, E, V, E  …  L, G, L, L, F, T, L, L, R, -]
 MIToS.MSA.Residue[-, E, D, L, F, Y, K, D, V, E  …  -, -, -, -, -, -, -, -, -, -]
 MIToS.MSA.Residue[K, K, D, L, F, Y, K, D, V, E  …  I, G, L, I, F, T, L, I, -, -]
 MIToS.MSA.Residue[K, K, D, L, F, Y, K, D, I, E  …  I, G, L, I, F, T, L, I, -, -]
 MIToS.MSA.Residue[K, K, D, L, F, Y, K, E, V, E  …  L, G, V, I, F, T, L, F, R, V]</code></pre></div><h2><a class="nav-anchor" id="Describing-your-MSA-1" href="#Describing-your-MSA-1">Describing your MSA</a></h2><p>The MSA module has a number of functions to gain insight about your MSA. Using <code>MIToS.MSA</code>, one can easily ask for...  </p><ul><li><p>The <strong>number of columns and sequences</strong> with the <code>ncolumns</code> and <code>nsequences</code> functions.  </p></li><li><p>The fraction of columns with residues (<strong>coverage</strong>) for each sequence making use of the</p></li></ul><p><code>coverage</code> method.  </p><ul><li><p>The <strong>fraction or percentage of gaps/residues</strong> using with the functions <code>gapfraction</code>,</p></li></ul><p><code>residuefraction</code> and <code>columngapfraction</code>.  </p><ul><li><p>The <strong>percentage of identity</strong> (PID) between each sequence of the MSA or its mean value</p></li></ul><p>with <code>percentidentity</code> and <code>meanpercentidentity</code>.  </p><p>The percentage identity between two aligned sequences it&#39;s a common measure of sequence similarity and it&#39;s used by the <code>hobohmI</code> method to estimate and reduce MSA redundancy. <strong>MIToS functions to calculate percent identity don&#39;t align the sequences, they need sequences already aligned.</strong> Full gaps columns don&#39;t count to the align length.  </p><div><pre><code class="language-julia">using MIToS.MSA

msa = permutedims(
        hcat(   res&quot;--GGG-&quot;,      # res&quot;...&quot; uses the @res_str macro to create a (column) Vector{Residue}
                res&quot;---GGG&quot; ), (2,1))
#        identities 000110 sum 2
#  aligned residues 001111 sum 4</code></pre></div><div><pre><code class="language-julia">percentidentity(msa[1,:], msa[2,:]) # 2 / 4</code></pre><pre><code class="language-none">50.0</code></pre></div><p>To quickly calculate if the percentage of identity is greater than a determined value, use that threshold as third argument. <code>percentidentity(seqa, seqb, pid)</code> is a lot more faster than <code>percentidentity(seqa, seqb) &gt;= pid</code>.  </p><div><pre><code class="language-julia">percentidentity(msa[1,:], msa[2,:], 62) # 50% &gt;= 62%</code></pre><pre><code class="language-none">false</code></pre></div><h4><a class="nav-anchor" id="Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence-1" href="#Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence-1">Example: Plotting gap percentage per column and coverage per sequence</a></h4><p>The <code>gapfraction</code> and <code>coverage</code> functions return a vector of number between <code>0.0</code> and <code>1.0</code> (fraction of...). Sometime it&#39;s useful to plot this data to quickly understand the MSA structure. In this example, we are going to use the <a href="http://plots.readthedocs.org/en/latest/">Plots<img src="assets/external-link.png" alt/></a> package for plotting, with a <a href="https://github.com/stevengj/PyPlot.jl">PyPlot<img src="assets/external-link.png" alt/></a> backend, but you are free to use any of the Julia plotting libraries.  </p><div></div><div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)

using Plots

pyplot(size=(600,300))

plot(   1:ncolumns(msa), # x is a range from 1 to the number of columns
        vec(columngapfraction(msa)) .* 100.0, # y is a Vector{Float64} with the percentage of gaps of each column
        linetype = :line,
        ylabel = &quot;gaps [%]&quot;,
        xlabel = &quot;columns&quot;,
        legend=false)</code></pre></div><p><img src="msa_gaps.png" alt/>  </p><div><pre><code class="language-julia">plot(   1:nsequences(msa), # x is a range from 1 to the number of sequences
        coverage(msa) .* 100, # y is a Vector{Float64} with the coverage of each sequence
        linetype = :line,
        ylabel = &quot;coverage [%]&quot;,
        xlabel = &quot;sequences&quot;,
        legend=false)</code></pre></div><p><img src="msa_coverage.png" alt/>  </p><div><pre><code class="language-julia">plot(msa)</code></pre></div><p><img src="msa_msa.png" alt/>  </p><h4><a class="nav-anchor" id="Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction-1" href="#Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction-1">Example: Filter sequences per coverage and columns per gap fraction</a></h4><p>Taking advantage of the <code>filter...!</code> functions and the <code>coverage</code> and <code>columngapfraction</code> functions, it&#39;s possible to delete short sequences or columns with a lot of gaps.  </p><div><pre><code class="language-julia">println(&quot;\tsequences\tcolumns&quot;)
println( &quot;Before:\t&quot;, nsequences(msa), &quot;\t\t&quot;, ncolumns(msa)  )
# delete sequences with less than 90% coverage of the MSA length:
filtersequences!(msa, coverage(msa) .&gt;= 0.9)
# delete columns with more than 10% of gaps:
filtercolumns!(msa, columngapfraction(msa) .&lt;= 0.1)
println( &quot;After:\t&quot;, nsequences(msa), &quot;\t\t&quot;,  ncolumns(msa)  )</code></pre><pre><code class="language-none">	sequences	columns
Before:	178		116
After:	55		108</code></pre></div><div><pre><code class="language-julia">histogram(  vec(columngapfraction(msa)),
            # Using vec() to get a Vector{Float64} with the fraction of gaps of each column
            xlabel = &quot;gap fraction in [0,1]&quot;, legend=false)</code></pre></div><p><img src="msa_hist_gaps.png" alt/>  </p><div><pre><code class="language-julia">histogram(  coverage(msa) .* 100.0, #  Column with the coverage of each sequence
            xlabel = &quot;coverage [%]&quot;, legend=false)</code></pre></div><p><img src="msa_hist_coverage.png" alt/>  </p><h4><a class="nav-anchor" id="Example:-Plotting-the-percentage-of-identity-between-sequences-1" href="#Example:-Plotting-the-percentage-of-identity-between-sequences-1">Example: Plotting the percentage of identity between sequences</a></h4><p>The distribution of the percentage of identity between every pairs of sequences in a MSA, gives an idea of the MSA diversity. In this example, we are going to use <code>percentidentity</code> over a MSA to get that values.  </p><div><pre><code class="language-julia">using MIToS.MSA
msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)
pid = percentidentity(msa)</code></pre></div><p>MIToS stores the matrix of percentage of identity between the aligned sequences as a PairwiseListMatrix from the <a href="http://diegozea.github.io/PairwiseListMatrices.jl/">PairwiseListMatrices<img src="assets/external-link.png" alt/></a> package. This matrix type saves RAM, allowing the storage of  big matrices. In this example, we use the <code>to_table</code> function of <em>PairwiseListMatrices</em> to convert the matrix into a table with indices.  </p><div><pre><code class="language-julia">using PairwiseListMatrices

pidtable = to_table(pid, diagonal=false)</code></pre><pre><code class="language-none">15753×3 Array{Any,2}:
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;G1RVK4_NOMLE/46-161&quot;       22.6087
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;A0A0V0S2G9_9BILA/731-840&quot;  25.4902
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;B4NHY3_DROWI/2-106&quot;        26.0417
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;G6CRH5_DANPL/1-73&quot;         23.3333
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;A0A194PY65_PAPXU/4-116&quot;    23.9583
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;RM55_DROME/2-106&quot;          24.7312
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;G5C999_HETGA/5-102&quot;        25.5319
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;G7Y6C1_CLOSI/30-139&quot;       20.6522
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;E0VEI6_PEDHC/4-112&quot;        30.0
 &quot;E4XN03_OIKDI/34-146&quot;     &quot;G3SRJ5_LOXAF/9-123&quot;        19.8276
 ⋮
 &quot;T1FXF3_HELRO/1-90&quot;       &quot;G3WPK1_SARHA/11-126&quot;       33.0435
 &quot;T1FXF3_HELRO/1-90&quot;       &quot;RM55_MOUSE/9-124&quot;          31.8966
 &quot;T1FXF3_HELRO/1-90&quot;       &quot;M3XPJ7_MUSPF/10-125&quot;       31.3043
 &quot;A0A090MXF3_STRRB/2-104&quot;  &quot;G3WPK1_SARHA/11-126&quot;       33.913
 &quot;A0A090MXF3_STRRB/2-104&quot;  &quot;RM55_MOUSE/9-124&quot;          30.1724
 &quot;A0A090MXF3_STRRB/2-104&quot;  &quot;M3XPJ7_MUSPF/10-125&quot;       31.3043
 &quot;G3WPK1_SARHA/11-126&quot;     &quot;RM55_MOUSE/9-124&quot;          54.3103
 &quot;G3WPK1_SARHA/11-126&quot;     &quot;M3XPJ7_MUSPF/10-125&quot;       62.6087
 &quot;RM55_MOUSE/9-124&quot;        &quot;M3XPJ7_MUSPF/10-125&quot;       70.6897</code></pre></div><p>The function <code>quantile</code> gives a quick idea of the percentage identity distribution of the MSA.  </p><div><pre><code class="language-julia">quantile(convert(Vector{Float64}, pidtable[:,3]), [0.00, 0.25, 0.50, 0.75, 1.00])</code></pre><pre><code class="language-none">5-element Array{Float64,1}:
   0.0
  27.1028
  31.8966
  38.2353
 100.0</code></pre></div><p>The function <code>meanpercentidentity</code> gives the mean value of the percent identity distribution for MSA with less than 300 sequences, or a quick estimate (mean PID in a random sample of sequence pairs) otherwise unless you set <code>exact</code> to <code>true</code>.  </p><div><pre><code class="language-julia">meanpercentidentity(msa)</code></pre><pre><code class="language-none">34.396463641886754</code></pre></div><p>One can easily plot that matrix and its distribution using the <code>heatmap</code> and <code>histogram</code> functions of the <a href="https://github.com/tbreloff/Plots.jl">Plots<img src="assets/external-link.png" alt/></a> package.  </p><div></div><div><pre><code class="language-julia">using Plots
pyplot()
heatmap(full(pid), yflip=true, ratio=:equal)</code></pre></div><p><img src="msa_heatmap_pid.png" alt/>  </p><div><pre><code class="language-julia">histogram(pidtable[:,3], xlabel =&quot;Percentage of identity&quot;, legend=false)</code></pre></div><p><img src="msa_hist_pid.png" alt/>  </p><h2><a class="nav-anchor" id="Sequence-clustering-1" href="#Sequence-clustering-1">Sequence clustering</a></h2><p>The <code>MSA</code> module allows to clusterize sequences in a MSA. The <code>hobohmI</code> function takes as input a MSA followed by an identity threshold value, and returns a <code>Clusters</code> type with the result of a <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2142204/">Hobohm I<img src="assets/external-link.png" alt/></a> sequence clustering. The Hobohm I algorithm will add a sequence to an existing cluster, if the percentage of identity is equal or greater than the threshold.   The <code>Clusters</code> is sub-type of <code>ClusteringResult</code> from the <a href="http://clusteringjl.readthedocs.org/en/latest/index.html">Clustering.jl<img src="assets/external-link.png" alt/></a> package. One advantage of use a sub-type of <code>ClusteringResult</code>is that you are able to use any method defined on <code>Clustering.jl</code> like <code>varinfo</code> (Variation of Information) for example. Also, you can use any clustering algorithm included in <em>Clustering.jl</em>, and convert its result to an <code>Clusters</code> object to use them with MIToS.   <code>MSA</code> defines the functions <code>nclusters</code> to get the resulting number of clusters, <code>counts</code> to get the number of sequences on each cluster and <code>assignments</code> to get the cluster number of each sequence. The most important method is <code>getweight</code>, which returns the weight of each sequence. This method is used in the <code>Information</code> module of MIToS to reduce redundancy.  </p><h4><a class="nav-anchor" id="Example:-Reducing-redundancy-of-a-MSA-1" href="#Example:-Reducing-redundancy-of-a-MSA-1">Example: Reducing redundancy of a MSA</a></h4><p>MSAs can suffer from an unnatural sequence redundancy and a high number of protein fragments. In this example, we will use a sequence clustering to make a non-redundant set of representative sequences using the function <code>hobohmI</code> to perform a clustering with the Hobohm I algorithm at 62% identity.  </p><div></div><div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)

println(&quot;This MSA has &quot;, nsequences(msa), &quot; sequences...&quot;)</code></pre><pre><code class="language-none">This MSA has 178 sequences...</code></pre></div><div><pre><code class="language-julia">clusters = hobohmI(msa, 62)</code></pre><pre><code class="language-none">MIToS.MSA.Clusters([1, 41, 2, 15, 2, 2, 1, 1, 1, 4  …  2, 3, 1, 1, 1, 2, 1, 1, 1, 1], [1, 2, 3, 4, 5, 4, 4, 2, 6, 7  …  16, 2, 17, 29, 4, 66, 29, 15, 2, 2], [1.0, 0.0243902, 0.5, 0.0666667, 0.5, 0.0666667, 0.0666667, 0.0243902, 0.5, 1.0  …  0.142857, 0.0243902, 0.142857, 0.25, 0.0666667, 1.0, 0.25, 0.333333, 0.0243902, 0.0243902])</code></pre></div><div><pre><code class="language-julia">println(&quot;...but has only &quot;, nclusters(clusters), &quot; sequence clusters after a clustering at 62% identity.&quot;)</code></pre><pre><code class="language-none">...but has only 66 sequence clusters after a clustering at 62% identity.</code></pre></div><div><pre><code class="language-julia">using Plots
pyplot()

plot(msa)</code></pre></div><p><img src="msa_clusters_i.png" alt/>  </p><p>We are going to use the <a href="http://dataframesjl.readthedocs.org/en/latest/">DataFrames<img src="assets/external-link.png" alt/></a> package to easily select the sequence with highest coverage of each cluster.  </p><div><pre><code class="language-julia">using DataFrames

df = DataFrame( seqnum = 1:nsequences(msa),
                seqname = sequencenames(msa),
                cluster = assignments(clusters), # the cluster number/index of each sequence
                coverage = vec(coverage(msa)))</code></pre><pre><code class="language-none">178×4 DataFrames.DataFrame
│ Row │ seqnum │ seqname                    │ cluster │ coverage │
├─────┼────────┼────────────────────────────┼─────────┼──────────┤
│ 1   │ 1      │ &quot;E4XN03_OIKDI/34-146&quot;      │ 1       │ 0.706897 │
│ 2   │ 2      │ &quot;G1RVK4_NOMLE/46-161&quot;      │ 2       │ 0.991379 │
│ 3   │ 3      │ &quot;A0A0V0S2G9_9BILA/731-840&quot; │ 3       │ 0.853448 │
│ 4   │ 4      │ &quot;B4NHY3_DROWI/2-106&quot;       │ 4       │ 0.810345 │
│ 5   │ 5      │ &quot;G6CRH5_DANPL/1-73&quot;        │ 5       │ 0.62931  │
│ 6   │ 6      │ &quot;A0A194PY65_PAPXU/4-116&quot;   │ 4       │ 0.810345 │
│ 7   │ 7      │ &quot;RM55_DROME/2-106&quot;         │ 4       │ 0.784483 │
│ 8   │ 8      │ &quot;G5C999_HETGA/5-102&quot;       │ 2       │ 0.801724 │
⋮
│ 170 │ 170    │ &quot;M3WM55_FELCA/10-125&quot;      │ 2       │ 1.0      │
│ 171 │ 171    │ &quot;A0A0C2BEU2_9BILA/5-105&quot;   │ 17      │ 0.801724 │
│ 172 │ 172    │ &quot;A0A0N5CCD5_STREA/1-104&quot;   │ 29      │ 0.836207 │
│ 173 │ 173    │ &quot;B4QTH5_DROSI/2-106&quot;       │ 4       │ 0.793103 │
│ 174 │ 174    │ &quot;T1FXF3_HELRO/1-90&quot;        │ 66      │ 0.775862 │
│ 175 │ 175    │ &quot;A0A090MXF3_STRRB/2-104&quot;   │ 29      │ 0.836207 │
│ 176 │ 176    │ &quot;G3WPK1_SARHA/11-126&quot;      │ 15      │ 0.991379 │
│ 177 │ 177    │ &quot;RM55_MOUSE/9-124&quot;         │ 2       │ 1.0      │
│ 178 │ 178    │ &quot;M3XPJ7_MUSPF/10-125&quot;      │ 2       │ 0.991379 │</code></pre></div><p>It is possible to use this <code>DataFrame</code> and <code>Plots</code> to plot the sequence coverage of the MSA and also an histogram of the number of sequences in each cluster:  </p><div><pre><code class="language-julia">using StatPlots # Plotting DataFrames
h = histogram(df[:cluster], ylabel=&quot;nseq&quot;)
p = plot(df, :cluster, :coverage, linetype=:scatter)
plot(p, h, nc=1, xlim=(0, nclusters(clusters)+1 ), legend=false)</code></pre></div><p><img src="msa_clusters_ii.png" alt/>  </p><p>We use the <em>Split-Apply-Combine</em> strategy, though the <code>by</code> function of the <code>DataFrames</code> package, to select the sequence of highest coverage for each cluster.  </p><div><pre><code class="language-julia">maxcoverage = by(df, :cluster, cl -&gt; cl[ findmax(cl[:coverage])[2] ,:])</code></pre><pre><code class="language-none">66×5 DataFrames.DataFrame
│ Row │ cluster │ seqnum │ seqname                    │ cluster_1 │ coverage │
├─────┼─────────┼────────┼────────────────────────────┼───────────┼──────────┤
│ 1   │ 1       │ 1      │ &quot;E4XN03_OIKDI/34-146&quot;      │ 1         │ 0.706897 │
│ 2   │ 2       │ 27     │ &quot;F7GI04_MACMU/7-122&quot;       │ 2         │ 1.0      │
│ 3   │ 3       │ 145    │ &quot;A0A0V0TDB0_9BILA/725-833&quot; │ 3         │ 0.862069 │
│ 4   │ 4       │ 72     │ &quot;Q177J1_AEDAE/3-112&quot;       │ 4         │ 0.87069  │
│ 5   │ 5       │ 5      │ &quot;G6CRH5_DANPL/1-73&quot;        │ 5         │ 0.62931  │
│ 6   │ 6       │ 167    │ &quot;A0A094ZMR1_SCHHA/3-104&quot;   │ 6         │ 0.810345 │
│ 7   │ 7       │ 10     │ &quot;E0VEI6_PEDHC/4-112&quot;       │ 7         │ 0.844828 │
│ 8   │ 8       │ 12     │ &quot;A0A0L8FVE8_OCTBM/8-111&quot;   │ 8         │ 0.818966 │
⋮
│ 58  │ 58      │ 168    │ &quot;B0WMT9_CULQU/9-116&quot;       │ 58        │ 0.818966 │
│ 59  │ 59      │ 153    │ &quot;A0A0N4ZNS7_PARTI/19-127&quot;  │ 59        │ 0.793103 │
│ 60  │ 60      │ 155    │ &quot;H3DW02_PRIPA/2-128&quot;       │ 60        │ 0.887931 │
│ 61  │ 61      │ 156    │ &quot;A0A0N4U7G0_DRAME/2-90&quot;    │ 61        │ 0.612069 │
│ 62  │ 62      │ 165    │ &quot;Q2KHY3_BOVIN/10-82&quot;       │ 62        │ 0.594828 │
│ 63  │ 63      │ 159    │ &quot;A0A0N5CW25_THECL/95-207&quot;  │ 63        │ 0.844828 │
│ 64  │ 64      │ 160    │ &quot;X6R631_HUMAN/1-52&quot;        │ 64        │ 0.448276 │
│ 65  │ 65      │ 163    │ &quot;A7RNQ0_NEMVE/28-143&quot;      │ 65        │ 0.818966 │
│ 66  │ 66      │ 174    │ &quot;T1FXF3_HELRO/1-90&quot;        │ 66        │ 0.775862 │</code></pre></div><div><pre><code class="language-julia">p = plot(maxcoverage, :cluster, :coverage, linetype=:scatter)
h = histogram(maxcoverage[:cluster], ylabel=&quot;nseq&quot;)
plot(p, h, nc=1, xlim=(0, nclusters(clusters)+1 ), legend=false)</code></pre></div><p><img src="msa_clusters_iii.png" alt/>  </p><p>We can easily generate a mask using list comprehension, to select only the representative sequences of the MSA (deleting the rest of the sequences with <code>filtersequences!</code>).  </p><div><pre><code class="language-julia">cluster_references = Bool[ seqnum in maxcoverage[:seqnum] for seqnum in 1:nsequences(msa) ]</code></pre><pre><code class="language-none">178-element Array{Bool,1}:
  true
 false
 false
 false
  true
 false
 false
 false
 false
  true
     ⋮
 false
 false
 false
 false
  true
 false
 false
 false
 false</code></pre></div><div><pre><code class="language-julia">filtersequences!(msa, cluster_references)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 90 annotations : 66×116 Named Array{MIToS.MSA.Residue,2}
                 Seq ╲ Col │  26   27   28   29   30  …  165  166  167  168  169
───────────────────────────┼────────────────────────────────────────────────────
E4XN03_OIKDI/34-146        │   -    -    -    -    -  …    -    -    -    -    -
G6CRH5_DANPL/1-73          │   -    -    -    -    -       K    Y    L    K    K
E0VEI6_PEDHC/4-112         │   -    -    -    -    -       N    L    L    K    K
A0A0L8FVE8_OCTBM/8-111     │   -    -    -    -    -       H    L    W    K    K
W4XCA5_STRPU/9-121         │   -    -    -    -    -       H    L    W    N    K
A0A0D8XRC7_DICVI/3-105     │   -    -    -    -    S       -    -    -    -    -
C4WSU2_ACYPI/2-101         │   -    -    -    -    -       K    Y    F    K    K
A0A0R3QN38_9BILA/5-118     │   -    -    -    -    -       D    L    W    R    K
G1TZ81_RABIT/10-122        │   L    L    W    Q    T       W    V    W    N    R
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
H3DW02_PRIPA/2-128         │   -    -    -    -    -       S    -    -    -    -
A0A0N4U7G0_DRAME/2-90      │   -    -    -    -    -       -    -    -    -    -
A0A0N5CW25_THECL/95-207    │   -    -    -    -    -       D    L    W    R    K
X6R631_HUMAN/1-52          │   -    -    -    -    -       Q    F    W    T    R
A7RNQ0_NEMVE/28-143        │   -    -    -    -    -       R    L    I    K    K
Q2KHY3_BOVIN/10-82         │   L    L    W    Q    C       -    -    -    -    -
A0A094ZMR1_SCHHA/3-104     │   -    -    -    -    -       F    L    L    K    K
B0WMT9_CULQU/9-116         │   -    -    -    -    -       K    Y    I    K    -
T1FXF3_HELRO/1-90          │   -    -    -    -    -  …    Y    L    W    K    K</code></pre></div><div><pre><code class="language-julia">plot(msa)</code></pre></div><p><img src="msa_clusters_iv.png" alt/>  </p><footer><hr/><a class="previous" href="Example.html"><span class="direction">Previous</span><span class="title">Example</span></a><a class="next" href="Information.html"><span class="direction">Next</span><span class="title">Information</span></a></footer></article></body></html>
